var documenterSearchIndex = {"docs":
[{"location":"TriangleHeaps.html#TriangleHeaps.jl","page":"TriangleHeaps","title":"TriangleHeaps.jl","text":"","category":"section"},{"location":"TriangleHeaps.html","page":"TriangleHeaps","title":"TriangleHeaps","text":"Documentation for TriangleHeaps.jl","category":"page"},{"location":"TriangleHeaps.html","page":"TriangleHeaps","title":"TriangleHeaps","text":"Modules = [IPGBs.TriangleHeaps]","category":"page"},{"location":"TriangleHeaps.html#IPGBs.TriangleHeaps","page":"TriangleHeaps","title":"IPGBs.TriangleHeaps","text":"Implements the S-pair triangles described in Roune and Stillman (2012), Section 4.3.\n\n\n\n\n\n","category":"module"},{"location":"TriangleHeaps.html#IPGBs.TriangleHeaps.TriangleHeap","page":"TriangleHeaps","title":"IPGBs.TriangleHeaps.TriangleHeap","text":"Stores a heap of SignaturePairs (i, j) containing only the S-pair of smallest signature for each i. Then, for each i, a row of triangle contains all the values of j such that (i, j) is still in the queue, without storing the signatures of these S-pairs. This reduces memory consumption.\n\nFor further improvements in memory consumption, we use the type parameter I to allow for smaller unsigned integer types. Using Uint16 allows computing with GBs of up to 65535 elements.\n\n\n\n\n\n","category":"type"},{"location":"TriangleHeaps.html#Base.isempty-Union{Tuple{IPGBs.TriangleHeaps.TriangleHeap{T, I}}, Tuple{I}, Tuple{T}} where {T, I}","page":"TriangleHeaps","title":"Base.isempty","text":"Returns true iff heap is empty. Just delegates to its internal heap, which is only empty when heap is.\n\n\n\n\n\n","category":"method"},{"location":"TriangleHeaps.html#Base.pop!-Union{Tuple{IPGBs.TriangleHeaps.TriangleHeap{T, I}}, Tuple{I}, Tuple{T}} where {T, I}","page":"TriangleHeaps","title":"Base.pop!","text":"Returns the SignaturePair of lowest signature in heap. Assumes that heap is non-empty.\n\n\n\n\n\n","category":"method"},{"location":"TriangleHeaps.html#IPGBs.TriangleHeaps.push_batch!-Union{Tuple{I}, Tuple{T}, Tuple{IPGBs.TriangleHeaps.TriangleHeap{T, I}, Vector{IPGBs.SignaturePolynomials.SignaturePair}}} where {T, I}","page":"TriangleHeaps","title":"IPGBs.TriangleHeaps.push_batch!","text":"Puts a batch of SignaturePairs (all coming from pairs (i, j) with fixed j) in heap, adding a new row to its triangle. Has to sort the S-pairs by signature, so its complexity is O(S * n log n) where S is the complexity of signature comparison and n = length(batch).\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#GBElements.jl","page":"GBElements","title":"GBElements.jl","text":"","category":"section"},{"location":"GBElements.html","page":"GBElements","title":"GBElements","text":"Documentation for GBElements.jl","category":"page"},{"location":"GBElements.html","page":"GBElements","title":"GBElements","text":"Modules = [IPGBs.GBElements]","category":"page"},{"location":"GBElements.html#IPGBs.GBElements","page":"GBElements","title":"IPGBs.GBElements","text":"This module defines all the binomial data structures used in my implementations of Buchberger's algorithm and Signature-based algorithms.\n\nTODO make GBElements a consistent interface\n\n\n\n\n\n","category":"module"},{"location":"GBElements.html#IPGBs.GBElements.GBElement","page":"GBElements","title":"IPGBs.GBElements.GBElement","text":"Abstract type used for GB computations. It is meant to generalize both binomials and binomials with signature, in order to simplify the implementation of reduction algorithms.\n\n\n\n\n\n","category":"type"},{"location":"GBElements.html#IPGBs.GBElements.degree_reducible-Union{Tuple{T}, Tuple{T, T}} where T<:IPGBs.GBElements.GBElement","page":"GBElements","title":"IPGBs.GBElements.degree_reducible","text":"This is only relevant when we consider the implicit representation of binomials. For this explicit representation, we can always return true.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.filter-Tuple{T} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.filter","text":"Gets the filter of a binomial, that is, the list of indices of variables appearing in its leading term.\n\nIf fullfilter = true, include the indices of variables appearing in its trailing term.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.head-Tuple{IPGBs.GBElements.GBElement}","page":"GBElements","title":"IPGBs.GBElements.head","text":"The indices of the positive support of g. Or indices of the support of leading_term(g)\n\nTODO could probably turn this into an iterator instead, would be more efficient\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.ipgbs_form-Tuple{Matrix{Int64}}","page":"GBElements","title":"IPGBs.GBElements.ipgbs_form","text":"Turns a 4ti2 GB into my GB format as a vector of integer vectors.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.is_negative_disjoint-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.is_negative_disjoint","text":"Checks whether the trailing terms of g and h are disjoint. In case negative = true, checks whether the leading term of g is disjoint with the trailing term of h.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.is_zero-Tuple{T} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.is_zero","text":"Returns true iff this binomial is zero, that is, all of its coordinates are 0.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.le_coordinatewise-Tuple{Vector{Int64}, Vector{Int64}}","page":"GBElements","title":"IPGBs.GBElements.le_coordinatewise","text":"Returns true iff v1 <= v2 coordinate-wise.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.le_upperbound-Union{Tuple{T}, Tuple{T, Vector{Union{Nothing, Int64}}}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.le_upperbound","text":"Checks whether v is bounded coordinate by coordinate by u.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.leading_term-Tuple{T} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.leading_term","text":"Computes the leading term of this GBElement as a vector.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.model_truncation-Union{Tuple{T}, Tuple{T, Matrix{Int64}, Vector{Int64}, JuMP.Model, Vector{JuMP.ConstraintRef}}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.model_truncation","text":"Checks feasibility of:\n\nAx = b - Av 0 <= x <= u\n\nwith x either a vector of real variables or integer variables, whatever is defined in model. In order to do this efficiently, updates the RHS of the previously built model by modifying constraints.\n\nReturns true iff v is feasible for the above model, which means it should NOT be truncated.\n\nTODO LP truncation is slightly slower than I hoped. IP truncation is very slow. Can I implement the model more efficiently somehow?\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.reduce!-Union{Tuple{T}, Tuple{T, T, IPGBs.Orders.GBOrder}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.reduce!","text":"Reduce binomial by reducer as many times as possible. Assumes reducer reduces binomial at least once.\n\nReturns true iff binomial reduced to 0.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.reduces-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{P, Vector{Int64}, T, S}} where {P<:AbstractVector{Int64}, T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"GBElements","title":"IPGBs.GBElements.reduces","text":"Checks whether reducer divides g, using the filter of reducer for efficiency. When fullfilter = true, checks if g.head >= reducer.head and g.tail >= reducer.tail coordinate-wise, while also checking a degree criterion.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.reduction_factor-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.reduction_factor","text":"Finds the maximum k such that k * reducer <= binomial coordinate-wise.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.simple_truncation-Union{Tuple{T}, Tuple{T, Matrix{Int64}, Vector{Int64}, Vector{Union{Nothing, Int64}}}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.simple_truncation","text":"Returns true iff v should be considered for reduction in a truncated GB algorithm.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.supports-Tuple{AbstractVector{Int64}}","page":"GBElements","title":"IPGBs.GBElements.supports","text":"Computes bitsets with positive and negative supports of g.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.supports-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.supports","text":"Computes bitsets with positive and negative supports of every element in B.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.to_gbelement-Union{Tuple{T}, Tuple{Vector{Int64}, T, DataType}} where T<:IPGBs.Orders.GBOrder","page":"GBElements","title":"IPGBs.GBElements.to_gbelement","text":"Turns a vector v into a GBElement of type S. Currently, Binomials are the only subtype supported.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.truncate-Union{Tuple{T}, Tuple{T, Matrix{Int64}, Vector{Int64}, Vector{Union{Nothing, Int64}}, JuMP.Model, Vector{JuMP.ConstraintRef}, Bool, Symbol}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.truncate","text":"Returns true iff binomial should be truncated according to the given truncation_type.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#BinomialSets.jl","page":"BinomialSets","title":"BinomialSets.jl","text":"","category":"section"},{"location":"BinomialSets.html","page":"BinomialSets","title":"BinomialSets","text":"Documentation for BinomialSets.jl","category":"page"},{"location":"BinomialSets.html","page":"BinomialSets","title":"BinomialSets","text":"Modules = [IPGBs.BinomialSets]","category":"page"},{"location":"BinomialSets.html#IPGBs.BinomialSets.BinomialSet","page":"BinomialSets","title":"IPGBs.BinomialSets.BinomialSet","text":"Represents a set of binomials (e.g. a partial or complete Gröbner Basis), including structures for efficient reduction of elements.\n\nIn order to allow 4ti2-form bases, we allow elements to be Vector{Int}, in addition to GBElements.\n\n\n\n\n\n","category":"type"},{"location":"BinomialSets.html#IPGBs.BinomialSets.auto_reduce_once!-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, Int64}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.auto_reduce_once!","text":"Reduces each element of the GB by the previous elements.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.change_ordering!-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, Matrix{Float64}, Matrix{Int64}, Vector{Int64}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.change_ordering!","text":"Changes the ordering of bs to a monomial order given by the matrix new_order.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.fourti2_form-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.fourti2_form","text":"Returns the binomials of bs as integer vectors in minimization form.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_groebner_basis-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_groebner_basis","text":"Returns true iff bs is a Gröbner Basis. This is checked by applying Buchberger's theorem and generating all S-binomials, thus may be slow. Note that this verifies if bs is a Gröbner Basis, but not a truncated Gröbner Basis. To check the latter case, use istruncatedgroebner_basis.\n\nUseful for debugging and automatic tests.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_negative_disjoint-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{T, S}, IPGBs.IPInstances.IPInstance}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_negative_disjoint","text":"Returns true iff the i-th and j-th vectors of bs have disjoint negative bounded components.\n\nThis is essentially 4ti2's cancellation criterion.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_positive_disjoint-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{T, S}, IPGBs.IPInstances.IPInstance}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_positive_disjoint","text":"Returns true iff the i-th and j-th vectors of bs have disjoint positive non-negative components.\n\nThis is essentially the GCD criterion.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_support_reducible-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{T, S}, IPGBs.IPInstances.IPInstance}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_support_reducible","text":"Returns true if (i, j) should be discarded.\n\nThis is an implementation of Criteria 1 and 2 from Malkin's thesis.\n\nCriterion 1 is simply the classical Buchberger GCD criterion. If the positive supports are disjoint (= GCD of the leading terms is 1) then the pair may be discarded.\n\nCriterion 2 is specific to homogeneous ideals (or just ideals coming from lattices?) Either way, if the negative supports are not disjoint (= GCD of trailing terms is not 1) then the pair may be discarded. This applies specifically to the bounded components (= variables) of the problem.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_truncated_groebner_basis-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, Matrix{Int64}, Vector{Int64}, Vector{Int64}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_truncated_groebner_basis","text":"Checks whether bs is a truncated Gröbner Basis where truncation is done with respect to\n\nAx <= b x <= u\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.minimal_basis!-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.minimal_basis!","text":"Updates gb to a minimal Gröbner Basis.\n\nFor more info on minimal GBs, see Lemma 3 from Cox, Little, O'Shea Chapter 2.7. In summary, it shows that one can remove from a GB any g such that LT(g) is a multiple of LT(h), for h distinct from g in the GB.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduce!-Union{Tuple{S}, Tuple{T}, Tuple{T, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduce!","text":"Reduces g by bs efficiently using a Support Tree. Returns a pair of booleans (r, c) where r == true iff g reduced to zero, and c == true iff g was changed in this reduction.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduce!-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.SupportTree{T}}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduce!","text":"Fully reduce binomial by gb in-place, finding its normal form. Uses tree to speed up the search for reducers. Returns a pair of booleans (r, c) where r == true iff g reduced to zero, and c == true iff g was changed in this reduction.\n\nbinomial can also be a monomial.\n\nIf reduction_count is given, the number of times each reducer was used in this reduction process is added to reduction_count. This greatly slows down execution, and is only meant for experimental purposes. The parameter should be set to nothing in practical runs.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduced_basis!-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduced_basis!","text":"Updates gb to a reduced Gröbner Basis.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.sbinomial-Union{Tuple{S}, Tuple{T}, Tuple{Vector{Int64}, IPGBs.GBElements.CriticalPair, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.sbinomial","text":"Creates a concrete S-binomial from pair. In practice, this should only be called after we were unable to eliminate pair.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#FastComparator.jl","page":"FastComparator","title":"FastComparator.jl","text":"","category":"section"},{"location":"FastComparator.html","page":"FastComparator","title":"FastComparator","text":"Documentation for FastComparator.jl","category":"page"},{"location":"FastComparator.html","page":"FastComparator","title":"FastComparator","text":"Modules = [IPGBs.FastComparator]","category":"page"},{"location":"FastComparator.html#IPGBs.FastComparator","page":"FastComparator","title":"IPGBs.FastComparator","text":"Implements fast comparisons of complex objects by building a structure of integers representing them.\n\nTODO currently repeated elements give different magnitudes. This is not necessarily a problem yet, but I should fix that if it ever becomes a problem\n\n\n\n\n\n","category":"module"},{"location":"FastComparator.html#IPGBs.FastComparator.Comparator","page":"FastComparator","title":"IPGBs.FastComparator.Comparator","text":"A structure allowing for O(1) comparison of elements of data. Updating the structure with new elements of data can take up to O(n). This is done by associating an integer to each element of data, such that data[i] < data[j] iff magnitudes[i] < magnitudes[j].\n\nTODO Maybe it is possible to optimize insertion to O(log n). Think about it later.\n\n\n\n\n\n","category":"type"},{"location":"FastComparator.html#Base.Order.lt-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64, Int64}} where {T, F}","page":"FastComparator","title":"Base.Order.lt","text":"Returns true iff the element of index index1 is smaller than that of index index2 in comp.data. Uses Comparator logic for comparison in O(1).\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.build!-Tuple{Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"FastComparator","title":"IPGBs.FastComparator.build!","text":"Returns a vector of sorted permutation indices and integer magnitudes of elements of data in the range given by [-range, range].\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.check_increasing_property-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.check_increasing_property","text":"Checks whether comp satisfies the increasing property, i.e. its elements in the order given by comp.sorted_permutation are in increasing order\n\nThis is useful for testing and debugging.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.compare-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64, Int64}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.compare","text":"Returns :lt, :eq, :gt if the element indexed by index1 is smaller, equal or greater than the one indexed by index2 respectively. Uses Comparator logic for comparison in O(1).\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.find_position-Union{Tuple{F}, Tuple{T}, Tuple{T, IPGBs.FastComparator.Comparator{T, F}}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.find_position","text":"Do a binary search for element on the data of comp to find the position where it should be inserted.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.increase_range!-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.increase_range!","text":"Increases the comparator range for magnitudes by RANGEUPDATEFACTOR when possible. If this is not possible, simply increases it to the maximum range possible (full integers).\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.ith_element-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.ith_element","text":"Returns the i-th element of the (sorted) data in comp.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.magnitude-Tuple{Int64, Int64, Int64}","page":"FastComparator","title":"IPGBs.FastComparator.magnitude","text":"Computes the magnitude of the i-th smallest element out of n elements with the given range. The elements are equally spaced in the range.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.occupation_ratio-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.occupation_ratio","text":"Ratio of occupied slots in [-comp.range, comp.range]\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.rebuild!-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.rebuild!","text":"Increases range and rebuilds comp, equally spacing the magnitudes of the elements in the new increased range.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.update!-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.update!","text":"Updates comp with the magnitudes and sorted positions of any new elements added to comp.data. May rebuild the whole structure whenever necessary.\n\nTODO is it possible to lower the complexity of this function from O(n) to O(log n) by avoiding the insertions in a vector? Maybe using some other kind of structure to store comp.sorted_permutation\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.update_magnitude!-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.update_magnitude!","text":"Inserts the magnitude of the element of rank rank in the magnitude list of comp. May rebuild the whole structure if there are no available magnitudes.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#GradedBinomials.jl","page":"GradedBinomials","title":"GradedBinomials.jl","text":"","category":"section"},{"location":"GradedBinomials.html","page":"GradedBinomials","title":"GradedBinomials","text":"Documentation for GradedBinomials.jl","category":"page"},{"location":"GradedBinomials.html","page":"GradedBinomials","title":"GradedBinomials","text":"Modules = [IPGBs.GradedBinomials]","category":"page"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials","page":"GradedBinomials","title":"IPGBs.GradedBinomials","text":"A structure for efficient computation of truncated GBs of IPs where the data is positive, as described in Section 3 of Thomas and Weismantel (1997). This type of implicit representation of GB elements is also used in Urbaniak, Weismantel and Ziegler (1997).\n\nTODO there are multiple implementations of sparse subtraction of GradedBinomials here. I should probably check whether I need them all\n\nTODO Currently, using GradedBinomials gives different (but apparently correct) GBs than using Binomials. There's probably something implicit about the monomial order they're computed wrt that I'm missing, due to one being maximization and the other being minimization.\n\nRegardless, I'm unconvinced this will ever be more efficient than the usual Binomials. The main reason is that the implicit variables are updated and checked in the reduction process regardless, only this happens in a different way in the SupportTree. A slightly different implementation, where the implicit variables aren't stored anywhere and are computed as needed could be useful if memory became an issue, but that is another thing entirely.\n\n\n\n\n\n","category":"module"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.GradedBinomial","page":"GradedBinomials","title":"IPGBs.GradedBinomials.GradedBinomial","text":"Represents a binomial as a vector of integers, tracking its leading and trailing terms and degree for easy and efficient implementation of truncated GBs.\n\n\n\n\n\n","category":"type"},{"location":"GradedBinomials.html#Base.:--Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"Base.:-","text":"Subtracts two GradedBinomials, updating head/tail and cost. This is more efficient than just subtracting directly.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#Base.:--Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"Base.:-","text":"Unary minus for GradedBinomials. It swaps head by tail and inverts cost.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#Base.setindex!-Tuple{IPGBs.GradedBinomials.GradedBinomial, Int64, Int64}","page":"GradedBinomials","title":"Base.setindex!","text":"Sets g at index i to v. In theory, this shouldn't be used, as GradedBinomials should not be changed.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.degree_reducible-Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.degree_reducible","text":"Checks whether g.degree+ <= h.degree coordinate-wise, where g.degree+ is the set of positive subset of coordinates of g.degree.\n\nIf negative == true, checks whether g.degree- <= h.degree-\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.fullform-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.fullform","text":"Given g = v+ - v-, returns the full form of g including slack variables. This is given by: x^(v+) s^((Av)-) r^(v-)   -   x^(v-) s^((Av)+) r^(v+)\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.minus-Tuple{Vector{Int64}, IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.minus","text":"TODO do this in a memory-efficient way by reusing result\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.opposite!-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.opposite!","text":"In-place unary minus for GradedBinomials\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.reduce!-Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial, IPGBs.Orders.GBOrder}","page":"GradedBinomials","title":"IPGBs.GBElements.reduce!","text":"Computes g -= h in place.\n\nReturns true iff g reduced to zero.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.supports-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.supports","text":"Computes bitsets with the positive and negative supports of g.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.decomposition-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.decomposition","text":"Decomposes g = v+ - v-, where both v+ and v- are non-negative arrays.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.filter-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.filter","text":"Computes the filter of binomial. In case fullfilter == false, this is just the indices in the support of the leading term of binomial.\n\nOtherwise (fullfilter == true) this is the vector of ordered indices of the support of binomial, so it also includes indices in the trailing term.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.fourti2_form-Tuple{Vector{IPGBs.GradedBinomials.GradedBinomial}}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.fourti2_form","text":"Transforms a vector of GradedBinomials into the form of 4ti2 input/output. This includes putting GradedBinomials into fullform, including all of their variables which are implicit in the GradedBinomial structure.\n\nIf is_maximization is true, assumes the GradedBinomials are in maximization form. As 4ti2 assumes minimization, signs have to be swapped.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.lattice_generator_graded","page":"GradedBinomials","title":"IPGBs.GradedBinomials.lattice_generator_graded","text":"Vector in Z^n with i-th coordinate 1 and remaining coordinates 0.\n\n\n\n\n\n","category":"function"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.reduce_negative!-Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.reduce_negative!","text":"Computes g = h - g changing g in-place. This is useful in the case g is supposed to be reduced by h but g.cost < h.cost.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#FGLM.jl","page":"FGLM","title":"FGLM.jl","text":"","category":"section"},{"location":"FGLM.html","page":"FGLM","title":"FGLM","text":"Documentation for FGLM.jl","category":"page"},{"location":"FGLM.html","page":"FGLM","title":"FGLM","text":"Modules = [IPGBs.FGLM]","category":"page"},{"location":"FGLM.html#IPGBs.FGLM.direct_normal_form-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.MonomialHeaps.WeightedMonomial, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.direct_normal_form","text":"direct_normal_form(m :: WeightedMonomial, gb :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}\n\nCompute the normal form of m with respect to gb by applying the usual reduction process directly.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.fast_normal_form-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.MonomialHeaps.WeightedMonomial, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.fast_normal_form","text":"fast_normal_form(m :: WeightedMonomial, gb :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}\n\nCompute the normal form of m with respect to gb by computing NormalForm(xi * NormalForm(m')) where m = xi * m'.\n\nThis is the method suggested in the original FGLM paper Faugère et al (1994).\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.fglm-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, S}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.fglm","text":"fglm(gb1 :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}\n\nConvert a Gröbner basis gb1 to target_order using the FGLM algorithm.\n\nFGLM only works when the ideal generated by gb1 is zero-dimensional. This is assumed in the implementation.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.find_linear_dependency-Tuple{Vector{Int64}, Dict{Vector{Int64}, Vector{Int64}}}","page":"FGLM","title":"IPGBs.FGLM.find_linear_dependency","text":"find_linear_dependency(nf :: Vector{Int}, std_basis :: Dict{Vector{Int}, Vector{Int}}\n\nReturn an element of std_basis with normal form nf, if such an element exists, otherwise return [].\n\nTODO It is likely possible to do this more efficient using some special kind of tree. I'll leave this for later, in case it's needed.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.is_below_staircase-Union{Tuple{T}, Tuple{IPGBs.MonomialHeaps.WeightedMonomial, Vector{T}}} where T","page":"FGLM","title":"IPGBs.FGLM.is_below_staircase","text":"is_below_staircase(m :: Vector{Int}, gb :: Vector{T}) where {T}\n\nChecks whether m is below the staircase given by gb. Naïve implementation. It is possible to do this more efficiently by counting the number of times FGLM generated m.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.is_below_staircase_fast-Tuple{IPGBs.MonomialHeaps.WeightedMonomial}","page":"FGLM","title":"IPGBs.FGLM.is_below_staircase_fast","text":"is_below_staircase_fast(m :: WeightedMonomial)\n\nCheck whether m is below a GB staircase indirectly by counting how many times it was inserted in the priority queue.\n\nThis idea comes straight from the original FGLM paper Faugère et al (1994).\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.update_monomial_heap!-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.MonomialHeaps.MonomialHeap{S}, IPGBs.MonomialHeaps.WeightedMonomial, T}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.update_monomial_heap!","text":"update_monomial_heap!(h :: MonomialHeap{T}, m :: Vector{Int}) where {T <: GBOrder}\n\nAdd all monomials of the form xi * m for all variables xi to the heap h and count repetitions.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#FourTi2.jl","page":"FourTi2","title":"FourTi2.jl","text":"","category":"section"},{"location":"FourTi2.html","page":"FourTi2","title":"FourTi2","text":"Documentation for FourTi2.jl","category":"page"},{"location":"FourTi2.html","page":"FourTi2","title":"FourTi2","text":"Modules = [IPGBs.FourTi2]","category":"page"},{"location":"FourTi2.html#IPGBs.FourTi2","page":"FourTi2","title":"IPGBs.FourTi2","text":"Basic Julia-4ti2 interface using system calls. Currently includes the minimize, groebner, normalform, markov and graver 4ti2 commands.\n\n\n\n\n\n","category":"module"},{"location":"FourTi2.html#IPGBs.FourTi2._4ti2_clear-Tuple{String}","page":"FourTi2","title":"IPGBs.FourTi2._4ti2_clear","text":"Internal use.\n\nRemoves the temporary files used to communicate between Julia and 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2._4ti2_read-Tuple{String}","page":"FourTi2","title":"IPGBs.FourTi2._4ti2_read","text":"Internal use.\n\nReads a Julia array from a given file written by 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2._4ti2_write-Union{Tuple{T}, Tuple{Array{T}, String}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2._4ti2_write","text":"Internal use.\n\nWrites a Julia array to a file in a format that can be read by 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.graver","page":"FourTi2","title":"IPGBs.FourTi2.graver","text":"Calls 4ti2's graver command.\n\nTODO Implement other options (lower and upper bound, arbitrary signs, support to lattice bases instead of matrices...)\n\n\n\n\n\n","category":"function"},{"location":"FourTi2.html#IPGBs.FourTi2.groebner-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.groebner","text":"Interface with the 4ti2 groebner command. Computes the Gröbner Basis of the toric ideal given by A using c as the ordering.\n\nIf lattice is true, A is a lattice basis instead.\n\nReturns the Gröbner Basis as a matrix where each row corresponds to a pure binomial in it.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.groebnernf-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.groebnernf","text":"Calls 4ti2's groebner command followed by normalform. This is equivalent to minimize, except it generates a Gröbner basis in as output and doesn't apply the optimizations of the latter command.\n\nReturns the optimal solution to the given IP along with its objective value.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.markov-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.markov","text":"Returns the minimal Markov basis of A with respect to c as a matrix, where the rows are the elements of the basis.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.minimize-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.minimize","text":"Interface with the 4ti2 minimize command. Solves the Integer Programming problem:\n\nmin c' * x s.t. A * x = b x >= 0\n\nwhere b = A * xinit using Gröbner Basis methods / 4ti2. This is essentially equivalent to calling groebner followed by normalform, but a few optimizations are applied (group relaxations + upper bounds)\n\nI found that –precision=arb is often necessary here to avoid errors.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.normalform-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.normalform","text":"Interface with the 4ti2 normalform command. Computes the normal form of xinit with respect to the Gröbner Basis of the toric ideal given by A using c as an ordering. This can be called multiple times for various xinit without recomputing the Gröbner Basis.\n\nReturns the normal form and its value using c as objective function.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.write_4ti2_input-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}, Vector{Bool}}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}, Vector{Bool}, Any}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.write_4ti2_input","text":"Writes an integer programming problem in 4ti2-readable format.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.write_4ti2_sign","page":"FourTi2","title":"IPGBs.FourTi2.write_4ti2_sign","text":"Writes sign file for 4ti2.\n\n\n\n\n\n","category":"function"},{"location":"Binomials.html#Binomials.jl","page":"Binomials","title":"Binomials.jl","text":"","category":"section"},{"location":"Binomials.html","page":"Binomials","title":"Binomials","text":"Documentation for Binomials.jl","category":"page"},{"location":"Binomials.html","page":"Binomials","title":"Binomials","text":"Modules = [IPGBs.Binomials]","category":"page"},{"location":"Binomials.html#IPGBs.Binomials.lattice_generator_binomial-Tuple{Int64, Matrix{Int64}, Vector{Int64}, Array{Float64}, Vector{Int64}, IPGBs.Orders.GBOrder}","page":"Binomials","title":"IPGBs.Binomials.lattice_generator_binomial","text":"Computes a Markov basis of A with c as cost matrix. This assumes the problem is in the particular form given in Thomas and Weismantel (1997), Section 3.\n\n\n\n\n\n","category":"method"},{"location":"Binomials.html#IPGBs.GBElements.minus-Tuple{Vector{Int64}, IPGBs.Binomials.Binomial, IPGBs.Binomials.Binomial}","page":"Binomials","title":"IPGBs.GBElements.minus","text":"Creates g - h in preallocated vector result.\n\n\n\n\n\n","category":"method"},{"location":"Binomials.html#IPGBs.GBElements.reduce!-Tuple{IPGBs.Binomials.Binomial, IPGBs.Binomials.Binomial, IPGBs.Orders.GBOrder}","page":"Binomials","title":"IPGBs.GBElements.reduce!","text":"In addition to applying the reduction itself, we update the cost.\n\nReturns true iff binomial reduced to 0.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#Markov.jl","page":"Markov","title":"Markov.jl","text":"","category":"section"},{"location":"Markov.html","page":"Markov","title":"Markov","text":"Documentation for Markov.jl","category":"page"},{"location":"Markov.html","page":"Markov","title":"Markov","text":"Modules = [IPGBs.Markov]","category":"page"},{"location":"Markov.html#IPGBs.Markov","page":"Markov","title":"IPGBs.Markov","text":"Implementation of algorithms to compute Markov bases. These are necessary as sets of generators of an ideal for computing Gröbner bases.\n\nTwo methods are implemented:\n\na simplified method that only works when all data defining an IP is negative\nthe project-and-lift algorithm of 4ti2 / Malkin's thesis\n\nTODO implement a Project-and-Lift state structure. This will facilitate the implementation of group relaxations and early termination, as well as iteratively computing parts of the GB and continuing later\n\n\n\n\n\n","category":"module"},{"location":"Markov.html#IPGBs.Markov.is_normalized_hnf-Union{Tuple{AbstractAlgebra.Generic.MatSpaceElem{T}}, Tuple{T}} where T","page":"Markov","title":"IPGBs.Markov.is_normalized_hnf","text":"is_normalized_hnf(H :: Generic.MatSpaceElem{T})\n\nReturn true iff H is in normalized HNF form as defined in normalize_hnf!.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.lex_groebner_basis-Tuple{IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.lex_groebner_basis","text":"lex_groebner_basis(instance :: IPInstance) :: BinomialSet\n\nCompute a lex Gröbner basis of instance using the HNF algorithm.\n\nIt is assumed the toric ideal of instance.A is zero-dimensional, i.e. that the lattice optimization problem given by instance is of rank n.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.markov_basis","page":"Markov","title":"IPGBs.Markov.markov_basis","text":"Compute a Markov basis of an IP.\n\n\n\n\n\n","category":"function"},{"location":"Markov.html#IPGBs.Markov.normalize_hnf!-Union{Tuple{AbstractAlgebra.Generic.MatSpaceElem{T}}, Tuple{T}} where T","page":"Markov","title":"IPGBs.Markov.normalize_hnf!","text":"normalize_hnf!(H :: Generic.MatSpaceElem{T})\n\nChange H to an upper row HNF matrix satisfying the following property: all entries above a pivot are non-positive and of smaller magnitude than the pivot\n\nAssumes H is already in HNF as defined by AbstractAlgebra.jl, that is, it is in upper row HNF satisfying:\n\nall entries above a pivot are non-negative and of smaller magnitude than the pivot\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.project_and_lift-Tuple{IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.project_and_lift","text":"project_and_lift(instance :: IPInstance, truncation_type :: Symbol) :: Vector{Vector{Int}}\n\nCompute a Markov basis of instance using the project-and-lift algorithm.\n\nTruncation is done with respect to truncation_type. If truncation_type is None, then a full Markov basis is computed instead.\n\nTODO I probably could make projections more efficient. But at least this way they are very simple to implement...\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.simple_markov-Tuple{IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.simple_markov","text":"simple_markov(instance :: IPInstance) :: Vector{Vector{Int}}\n\nCompute a Markov basis of instance with the simplified algorithm. Assumes all data in instance.A and instance.b is non-negative.\n\nThe simplified algorithm uses the fact (proved in, e.g. Thomas and Weismantel (1997)) that the unit vectors on the original variables of the IP form a Markov basis.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.truncate_markov-Tuple{Vector{Vector{Int64}}, IPGBs.IPInstances.IPInstance, Symbol}","page":"Markov","title":"IPGBs.Markov.truncate_markov","text":"truncate_markov(markov :: Vector{Vector{Int}}, instance :: IPInstance, truncation_type :: Symbol) :: Vector{Vector{Int}}\n\nCompute a subset of markov including only vectors which shouldn't be truncated according to the rule given by truncation_type.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#FastBitSets.jl","page":"FastBitSets","title":"FastBitSets.jl","text":"","category":"section"},{"location":"FastBitSets.html","page":"FastBitSets","title":"FastBitSets","text":"Documentation for FastBitSets.jl","category":"page"},{"location":"FastBitSets.html","page":"FastBitSets","title":"FastBitSets","text":"Modules = [IPGBs.FastBitSets]","category":"page"},{"location":"FastBitSets.html#IPGBs.FastBitSets","page":"FastBitSets","title":"IPGBs.FastBitSets","text":"Specialized module for faster bitsets in the context of GBs / IP.\n\n\n\n\n\n","category":"module"},{"location":"FastBitSets.html#IPGBs.FastBitSets.BitTriangle","page":"FastBitSets","title":"IPGBs.FastBitSets.BitTriangle","text":"A BitTriangle stores a bit of data for each pair (i, j) with i != j. Data can be set and accessed for both (i, j) and (j, i), even though it is only stored once per pair.\n\n\n\n\n\n","category":"type"},{"location":"FastBitSets.html#Base.getindex-Tuple{IPGBs.FastBitSets.FastBitSet, Int64}","page":"FastBitSets","title":"Base.getindex","text":"Truth value associated by this bitset to the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#IPGBs.FastBitSets.add_row!-Tuple{IPGBs.FastBitSets.BitTriangle}","page":"FastBitSets","title":"IPGBs.FastBitSets.add_row!","text":"Adds a new row (initialized to false) to this BitTriangle. If this is the n-th row, it will have (n-1) elements.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#IPGBs.FastBitSets.check_indices-Tuple{Any, Any}","page":"FastBitSets","title":"IPGBs.FastBitSets.check_indices","text":"Checks whether the indices i, j can be a pair in a bit triangle. In practice, this means they have to be different.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#IPGBs.FastBitSets.triangle_indices-Tuple{Any, Any}","page":"FastBitSets","title":"IPGBs.FastBitSets.triangle_indices","text":"Swaps indices so that they are access a valid pair in a bit triangle.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#Orders.jl","page":"Orders","title":"Orders.jl","text":"","category":"section"},{"location":"Orders.html","page":"Orders","title":"Orders","text":"Documentation for Orders.jl","category":"page"},{"location":"Orders.html","page":"Orders","title":"Orders","text":"Modules = [IPGBs.Orders]","category":"page"},{"location":"Orders.html#IPGBs.Orders.GBOrder","page":"Orders","title":"IPGBs.Orders.GBOrder","text":"This is specialized by MonomialOrder in case of Buchberger's algorithm and by ModuleMonomialOrder in case of Signature-based algorithms.\n\n\n\n\n\n","category":"type"},{"location":"Orders.html#IPGBs.Orders.MonomialOrder","page":"Orders","title":"IPGBs.Orders.MonomialOrder","text":"Implements a monomial order from a given cost matrix, including a grevlex tiebreaker if necessary.\n\nThe cost matrix is represented in column-major order to speed up comparisons.\n\n\n\n\n\n","category":"type"},{"location":"Orders.html#IPGBs.Orders.change_ordering!-Tuple{IPGBs.Orders.MonomialOrder, Matrix{Float64}, Matrix{Int64}, Vector{Int64}}","page":"Orders","title":"IPGBs.Orders.change_ordering!","text":"change_ordering!(order :: MonomialOrder, new_order :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int})\n\nChange the order stored in MonomialOrder to a new order.\n\nThe tiebreaker is rebuilt if necessary.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.invert_maximization-Tuple{IPGBs.Orders.MonomialOrder, Bool}","page":"Orders","title":"IPGBs.Orders.invert_maximization","text":"invert_maximization(order :: MonomialOrder, result :: Bool)\n\nInvert result when order is a maximization order.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.is_inverted-Union{Tuple{T}, Tuple{IPGBs.Orders.MonomialOrder, T, Real}} where T<:AbstractVector{Int64}","page":"Orders","title":"IPGBs.Orders.is_inverted","text":"is_inverted(order :: MonomialOrder, v :: T, cost :: Int) :: Bool where {T <: AbstractVector{Int}}\n\nEfficiently return whether v's leading and trailing terms are inverted.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.is_inverted_generic-Union{Tuple{T}, Tuple{IPGBs.Orders.MonomialOrder, T}} where T<:AbstractVector{Int64}","page":"Orders","title":"IPGBs.Orders.is_inverted_generic","text":"is_inverted_generic(order :: MonomialOrder, v :: T) :: Bool where {T <: AbstractVector{Int}}\n\nReturn true iff the trailing and leading terms of v are inverted with respect to order.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.is_inverted_invlex-Union{Tuple{T}, Tuple{IPGBs.Orders.MonomialOrder, T}} where T<:AbstractVector{Int64}","page":"Orders","title":"IPGBs.Orders.is_inverted_invlex","text":"is_inverted_invlex(order :: MonomialOrder, v :: T) :: Bool where {T <: AbstractVector{Int}}\n\nReturn true iff the trailing and leading terms of v are inverted with respect to the invlex order.\n\nv is inverted according to invlex iff its first non-zero entry is positive. Inversion testing is thus done more efficiently in the invlex case.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.lex_order-Tuple{Int64}","page":"Orders","title":"IPGBs.Orders.lex_order","text":"lex_order(n :: Int) :: MonomialOrder\n\nReturn the lex monomial order with x1 > x2 > ... > xn.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.normalize_order-Tuple{Matrix{Float64}, Matrix{Int64}, Vector{Int64}, Int64}","page":"Orders","title":"IPGBs.Orders.normalize_order","text":"normalize_order(C :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int}, num_vars :: Int)\n\nReturn a cost matrix in column-major form giving the same monomial order as C using only the first num_vars variables.\n\nNormalization uses the dual data of the LP min C*x s.t. Ax = b, x >= 0.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.order_cost-Tuple{IPGBs.Orders.MonomialOrder, AbstractVector{Int64}}","page":"Orders","title":"IPGBs.Orders.order_cost","text":"order_cost(order :: MonomialOrder, v :: AbstractVector{Int})\n\nThe cost of some vector according to the cost matrix of order.\n\nThis is the vector weighted by the first column of the cost matrix.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.positive_first_row!-Tuple{Matrix{Float64}, Matrix{Int64}, Vector{Int64}}","page":"Orders","title":"IPGBs.Orders.positive_first_row!","text":"positive_first_row!(C :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int})\n\nModify C so that its first row is strictly positive using dual data from the LP min C*x s.t. Ax = b, x >= 0.\n\nAssumes the given LP is bounded and feasible.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.projection_order-Tuple{Matrix{Float64}, Matrix{Int64}, Vector{Int64}, Int64}","page":"Orders","title":"IPGBs.Orders.projection_order","text":"projection_order(C :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int}, num_vars :: Int)\n\nReturn a matrix corresponding to the same monomial order as C but using only the first num_vars variables.\n\nUses the dual of the LP min C*x s.t. Ax = b, x >= 0 to find such an order.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.tiebreak-Tuple{Matrix{Float64}}","page":"Orders","title":"IPGBs.Orders.tiebreak","text":"tiebreak(C :: Matrix{Float64}) :: Matrix{Float64}\n\nReturn a matrix corresponding to the same monomial order as C, tiebreaking it using the revlex order if C does not already specify a full monomial order itself.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#StandardDecomposition.jl","page":"StandardDecomposition","title":"StandardDecomposition.jl","text":"","category":"section"},{"location":"StandardDecomposition.html","page":"StandardDecomposition","title":"StandardDecomposition","text":"Documentation for StandardDecomposition.jl","category":"page"},{"location":"StandardDecomposition.html","page":"StandardDecomposition","title":"StandardDecomposition","text":"Modules = [IPGBs.StandardDecomposition]","category":"page"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.AdmissiblePair","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.AdmissiblePair","text":"Represents an admissible pair, i.e., (x^m, σ) where x^m is a standard monomial and σ is a set of indices disjoint from the support of m.\n\nAdditionally, for this pair to be standard, it has to be minimal w.r.t. the following order: (x^m, σ) <= (x^m', σ') iff x^m divides x^m' and supp(x^m' / x^m) ∪ σ' ⊆ σ.\n\nThe minimal elements w.r.t. this order are the standard pairs and they cover other admissible pairs.\n\n\n\n\n\n","category":"type"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.choose_generator-Tuple{Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.choose_generator","text":"Chooses some generator of the monomial ideal M. For now, it simply picks the first one.\n\nTODO If I ever care about the performance of the standard decomposition, I can try to study whether it matters which generator is picked or not.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.choose_variable-Tuple{Vector{Int64}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.choose_variable","text":"Chooses some variable in the support of monomial. For now, it simply picks the first one.\n\nTODO The same comments from choose_generator apply here.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.ideal_quotient-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Int64}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.ideal_quotient","text":"Quotient of (M : (gen / x^i)). The generators of the quotient are the generators m of M divided by gcd(m, gen / x^i)\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.is_reducible-Tuple{Int64, Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.is_reducible","text":"True iff some generator in gens reduces the i-th element of gens.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.is_standard-Tuple{IPGBs.StandardDecomposition.AdmissiblePair, Vector{IPGBs.StandardDecomposition.AdmissiblePair}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.is_standard","text":"pair is_standard when it is not dominated by any already known standard pairs.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.less_than-Tuple{IPGBs.StandardDecomposition.AdmissiblePair, IPGBs.StandardDecomposition.AdmissiblePair}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.less_than","text":"Implements the following order: (x^m, σ) <= (x^m', σ') iff x^m divides x^m' and supp(x^m' / x^m) ∪ σ' ⊆ σ.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.minimal_generators-Tuple{Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.minimal_generators","text":"Reduces a set of generators gens to a set of minimal generators of the same monomial ideal.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.standard_decomposition-Tuple{Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.standard_decomposition","text":"Implementation of the standard decomposition algorithm introduced in Hosten and Thomas (1998).\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.support_in-Tuple{Vector{Int64}, Vector{Bool}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.support_in","text":"Returns true iff the support of monomial is contained in the set represented by sigma.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.update_ideal!-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.update_ideal!","text":"Updates the set of minimal generators of the ideal generated by gens upon adding new_gen.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#GBAlgorithms.jl","page":"GBAlgorithms","title":"GBAlgorithms.jl","text":"","category":"section"},{"location":"GBAlgorithms.html","page":"GBAlgorithms","title":"GBAlgorithms","text":"Documentation for GBAlgorithms.jl","category":"page"},{"location":"GBAlgorithms.html","page":"GBAlgorithms","title":"GBAlgorithms","text":"Modules = [IPGBs.GBAlgorithms]","category":"page"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.GBAlgorithm","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.GBAlgorithm","text":"A generic Gröbner Basis algorithm. Currently, it can be either a BuchbergerAlgorithm or a SignatureAlgorithm.\n\n\n\n\n\n","category":"type"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.increment-Tuple{IPGBs.GBAlgorithms.GBAlgorithm, Symbol}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.increment","text":"increment(algorithm :: GBAlgorithm, stat :: Symbol)\n\nIncrement the field stat of stats(algorithm)\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.is_minimization-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.is_minimization","text":"is_minimization(algorithm :: GBAlgorithm) :: Bool\n\nReturn true iff this algorithm is working with problems in minimization form.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.late_pair_elimination-Tuple{IPGBs.GBAlgorithms.GBAlgorithm, IPGBs.GBElements.CriticalPair}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.late_pair_elimination","text":"late_pair_elimination(:: GBAlgorithm, :: CriticalPair)\n\nReturn true iff the given CriticalPair should be eliminated according to this algorithm's criteria.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.prepare_gb_output-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.prepare_gb_output","text":"prepare_gb_output(algorithm :: GBAlgorithm) :: Vector{Vector{Int}}\n\nReturn the user-friendly output Gröbner Basis of algorithm, reduced, sorted and in the original variable ordering.\n\nThis output is compatible with 4ti2's output format.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.reintroduce_truncated!-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.reintroduce_truncated!","text":"reintroduce_truncated!(algorithm :: GBAlgorithm)\n\nAdd truncated elements of the given Markov basis back into the GB.\n\nThis is used at the end of the computation to keep the GB as a basis of the input ideal, regardless of truncation.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.run-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.run","text":"run(algorithm :: GBAlgorithm, quiet :: Bool) :: Vector{Vector{Int}}\n\nReturn the Gröbner Basis obtained by running algorithm.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPInstances.jl","page":"IPInstances","title":"IPInstances.jl","text":"","category":"section"},{"location":"IPInstances.html","page":"IPInstances","title":"IPInstances","text":"Documentation for IPInstances.jl","category":"page"},{"location":"IPInstances.html","page":"IPInstances","title":"IPInstances","text":"Modules = [IPGBs.IPInstances]","category":"page"},{"location":"IPInstances.html#IPGBs.IPInstances.IPInstance","page":"IPInstances","title":"IPGBs.IPInstances.IPInstance","text":"Represents an instance of a problem\n\nmin C * x\n\ns.t. A * x = b\n\n0 <= x <= u\n\nx in ZZ^n\n\nThe instance is stored in normalized form, with permuted variables so that the variables appear in the following order: bounded, non-negative but unbounded, unrestricted.\n\n\n\n\n\n","category":"type"},{"location":"IPInstances.html#IPGBs.IPInstances.apply_permutation-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"IPInstances","title":"IPGBs.IPInstances.apply_permutation","text":"apply_permutation(vector_set :: Vector{Vector{Int}}, permutation :: Vector{Int}) :: Vector{Vector{Int}}\n\nApply permutation to each vector in vector_set.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.bounded_variables-Tuple{JuMP.Model, Vector{JuMP.VariableRef}, Vector{JuMP.ConstraintRef}, Vector{Int64}}","page":"IPInstances","title":"IPGBs.IPInstances.bounded_variables","text":"bounded_variables(model :: JuMP.Model, model_vars :: Vector{JuMP.VariableRef}) :: Vector{Bool}\n\nReturn a boolean array indicating whether a given variable is bounded.\n\nA variable xi is bounded for the given model iff max {xi | x feasible for model} is bounded for all feasible RHS.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.compute_permutation-Tuple{Vector{Bool}, Vector{Bool}}","page":"IPInstances","title":"IPGBs.IPInstances.compute_permutation","text":"compute_permutation(bounded :: Vector{Bool}, nonnegative :: Vector{Bool}) :: Tuple{Vector{Int}, Int, Int}\n\nReturn a permutation of variables that puts the variables in the order [ bounded ; unbounded and restricted ; unrestricted ], along with the indices of the last bounded variable and the last unbounded but restricted variable.\n\nThis operation should be stable with respect to the initial ordering of variables.\n\nA permutation is represented by a vector perm such that perm[i] = j means that variable i is sent to j by the permutation.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.extract_bound-Tuple{JuMP.Model, JuMP.ConstraintRef, Vector{JuMP.VariableRef}}","page":"IPInstances","title":"IPGBs.IPInstances.extract_bound","text":"extract_bound(model :: JuMP.Model, c :: JuMP.ConstraintRef, x :: Vector{JuMP.VariableRef})\n\nExtract lower / upper bound value from a VariableRef type constraint c.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.extract_constraint-Tuple{JuMP.Model, JuMP.ConstraintRef, Vector{JuMP.VariableRef}}","page":"IPInstances","title":"IPGBs.IPInstances.extract_constraint","text":"extract_constraint(model :: JuMP.Model, c :: JuMP.ConstraintRef, x :: Vector{JuMP.VariableRef})\n\nExtract numerical coefficients from a JuMP constraint, returning a vector with left-hand side coefficients and the right-hand side value.\n\nAssumes this is a scalar constraint (= a single constraint).\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.group_relaxation-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.group_relaxation","text":"group_relaxation(instance :: IPInstance) :: IPInstance\n\nReturn a new IPInstance corresponding to the relaxation in instance of the non-negativity constraints of the basic variables in the optimal solution of its linear relaxation.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.is_bounded-Tuple{Int64, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.is_bounded","text":"is_bounded(i :: Int, instance :: IPInstance) :: Bool\n\nReturn true iff the variable of index i in instance is bounded.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.is_nonnegative-Tuple{Int64, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.is_nonnegative","text":"is_nonnegative(i :: Int, instance :: IPInstance) :: Bool\n\nReturn true iff the variable of index i in instance is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.lift_vector-Tuple{Vector{Int64}, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.lift_vector","text":"lift_vector(v :: Vector{Int}, instance :: IPInstance) :: Vector{Int}\n\nLift v from an (extended) group relaxation to the full problem given by instance.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.nonnegative_data_only-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.nonnegative_data_only","text":"nonnegative_data_only(instance :: IPInstance) :: Bool\n\nReturn true iff all data in instance.A and instance.b is non-negative and all variables are non-negative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.nonnegative_vars-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.nonnegative_vars","text":"nonnegative_vars(instance :: IPInstance) :: Vector{Bool}\n\nReturn a boolean vector indicating whether each variable of instance is non-negative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.nonnegativity_relaxation-Tuple{IPGBs.IPInstances.IPInstance, Vector{Bool}}","page":"IPInstances","title":"IPGBs.IPInstances.nonnegativity_relaxation","text":"nonnegativity_relaxation(instance :: IPInstance, nonnegative :: Vector{Bool}) :: IPInstance\n\nReturn a new IPInstance corresponding to the relaxation of instance consisting of only keeping the non-negativity constraints of variables marked in nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.normalize_ip-Union{Tuple{T}, Tuple{Matrix{Int64}, Vector{Int64}, Matrix{T}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}}} where T<:Real","page":"IPInstances","title":"IPGBs.IPInstances.normalize_ip","text":"normalize_ip(A :: Matrix{Int}, b :: Vector{Int}, c :: Matrix{T}, u :: Vector{<: Union{Int, Nothing}}, nonnegative :: Vector{Bool}; ...) where {T <: Real}\n\nTransform a problem in the form: max C * x s.t. Ax <= b 0 <= x <= u\n\nto something of the form max C * x s.t. Ax == b x == u\n\nby adding slack variables.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.original_variable_order-Tuple{Vector{Vector{Int64}}, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.original_variable_order","text":"original_variable_order(vector_set :: Vector{Vector{Int}}, instance :: IPInstance) :: Vector{Vector{Int}}\n\nInvert the variable permutation of instance over vector_set, returning to the original problem's variable order.\n\nThis is useful to give users output in the same variable order they input.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.random_ipinstance-Tuple{Int64, Int64}","page":"IPInstances","title":"IPGBs.IPInstances.random_ipinstance","text":"random_instance(m :: Int, n :: Int) :: IPInstance\n\nReturn a random feasible IPInstance with m constraints and n variables.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.unboundedness_proof-Tuple{IPGBs.IPInstances.IPInstance, Vector{Bool}, Int64}","page":"IPInstances","title":"IPGBs.IPInstances.unboundedness_proof","text":"unboundedness_proof(instance :: IPInstance, nonnegative :: Vector{Bool}, i :: Int) :: Vector{Int}\n\nReturn a vector u in kernel(instance.A) proving that the variable of index i is unbounded.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.update_objective!-Tuple{IPGBs.IPInstances.IPInstance, Int64}","page":"IPInstances","title":"IPGBs.IPInstances.update_objective!","text":"update_objective!(instance :: IPInstance, i :: Int)\n\nUpdate the objective function of instance to maximizing its i-th variable (= minimizing -x_i)\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#SignaturePolynomials.jl","page":"SignaturePolynomials","title":"SignaturePolynomials.jl","text":"","category":"section"},{"location":"SignaturePolynomials.html","page":"SignaturePolynomials","title":"SignaturePolynomials","text":"Documentation for SignaturePolynomials.jl","category":"page"},{"location":"SignaturePolynomials.html","page":"SignaturePolynomials","title":"SignaturePolynomials","text":"Modules = [IPGBs.SignaturePolynomials]","category":"page"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials","text":"Implementation of the basic signature-polynomial pairs structures.\n\nTODO this whole module would probably be cleaner if it was separated in multiple modules. One defining signatures, another defining module monomial orders, another defining SigPolys and so on.\n\n\n\n\n\n","category":"module"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ModuleMonomialOrder","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ModuleMonomialOrder","text":"An enum containing all types of module monomial orders available for this signature algorithm implementation.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ModuleMonomialOrdering","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ModuleMonomialOrdering","text":"Represents a module monomial ordering. This has to store a reference to the current basis in order to implement an order like lt-pot (Schreyer's order).\n\nThis is mutable because, for convenience, it may sometimes be necessary to change monomial_order.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.SigPoly","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.SigPoly","text":"Represents a polynomial with its signature. Used in signature-based algorithms. Stores its sig-lead ratio to compare signatures more efficiently when building S-pairs, Koszul syzygies, reductions and elimination criteria.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.Signature","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.Signature","text":"A signature, or module monomial, is represented by a monomial with an index, where the monomial is the coefficient of the module basis vector of the given index.\n\nTODO I'm thinking that monomial could easily be a sparse vector in cases with many variables. I expect many entries to be 0 in this case, but it is worth it to experiment with that.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.SignaturePair","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.SignaturePair","text":"An S-pair represented sparsely, before building it from binomials explicitly. Includes a signature to allow the signature-based algorithm to proceed by increasing signature of S-pairs.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#Base.Order.lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"Base.Order.lt","text":"Compares two SigPolys as polynomials wrt to the monomial order of o. Ignores signatures and sig-leads.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#Base.Order.lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}, IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"Base.Order.lt","text":"Compares two signatures with respect to the given ModuleMonomialOrdering. Returns true iff s1 is strictly smaller than s2 with respect to o.\n\nTODO I wonder if I shouldn't also store the weighted versions of signature.monomial This could make all orders more efficient, the obvious tradeoff being memory.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.build-Union{Tuple{T}, Tuple{Vector{Int64}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.build","text":"Builds u - v with signature given by pair.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.degree_reducible-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.degree_reducible","text":"Checks a reduction condition for implicit variables in the case T == GradedBinomial. Currently unused, because GradedBinomials are not supported with signatures.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.reduce!-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.Orders.GBOrder}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.reduce!","text":"Computes g -= h in-place, assumes this is a regular reduction, so that sig(g - h) = sig(g).\n\nReturns true iff g reduced to zero.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.signature_reducible-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.Signature, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.signature_reducible","text":"Checks whether g is signature reducible by a reducer with reducer_sig. This means the reducer (after multiplying by a lt quotient) has lower signature than g wrt the module monomial ordering.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.singular_top_reducible-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.Signature}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.singular_top_reducible","text":"Checks whether g is singular top-reducible by some reducer with signature reducer_sig. Assumes this reducer divides g.\n\nTODO singulartopreducible and signaturereducible both compare the same signatures. I could call the same function signaturecompare in both! In fact, given the situation I use this, I should just call signature_compare there and be done with it!\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.divides-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.divides","text":"Returns true iff s1 divides s2.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.image_leading_term-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, Array{IPGBs.SignaturePolynomials.SigPoly{T}, 1}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.image_leading_term","text":"Returns the leading term image of s by the function mapping the module basis element of index i to the i-th element of generators.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.koszul-Union{Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.koszul","text":"Returns the Koszul signature of the pair of gb indexed by (i, j), if it is regular. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ltpot_compare-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder, Array{IPGBs.SignaturePolynomials.SigPoly{T}, 1}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ltpot_compare","text":"Compares s1 and s2 in Schreyer's order (aka ltpot). This means first comparing the leading terms of the images of the signatures in the polynomial ring and then breaking ties by the pot order.\n\nReturns :lt, :eq or :gt if s1 is smaller, equal or greater than s2 respectively.\n\nTODO try to implement this more efficiently. The way I'm doing this here is very slow, due to all the calls to imageleadingterm...\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ltpot_lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder, Array{IPGBs.SignaturePolynomials.SigPoly{T}, 1}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ltpot_lt","text":"Returns true iff s1 < s2 in the ltpot (Schreyer) order.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.pot_compare-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.pot_compare","text":"Compares s1 and s2 in the position-over-term (pot) order, that is, compare signatures first by module index and break ties by the given monomial order on the coefficients.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.pot_lt-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.pot_lt","text":"Returns true iff s1 < s2 in the top order.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.regular_spair-Union{Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.regular_spair","text":"Creates an SPair S(i, j) if it is regular, otherwise returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.siglead-Union{Tuple{T}, Tuple{T, IPGBs.SignaturePolynomials.Signature}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.siglead","text":"Computes the SigLead ratio of binomial with signature. This is defined as a signature with the same index as signature, but with monomial defined by signature.monomial - leading_term(binomial)\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.signature_compare-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.signature_compare","text":"Returns :lt, :eq or :gt when sig1 is respectively smaller, equal or greater than sig2 with respect to module_order.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.signature_lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.signature_lt","text":"Returns sig1 < sig2 according to the given module_order\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.spair_signature-Union{Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.spair_signature","text":"Computes the signature of the i-branch of the S-pair (i, j). Just call with i and j inverted to compute the same thing for j.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.top_compare-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.top_compare","text":"Compares s1 and s2 in the term-over-position (top) order, that is, compare signature first by monomial order on the coefficients breaking ties by the module index.\n\nReturns :lt, :eq or :gt if s1 is smaller, equal or greater than s2 respectively.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.top_lt-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.top_lt","text":"Returns true iff s1 < s2 in the top order.\n\n\n\n\n\n","category":"method"},{"location":"Buchberger.html#Buchberger.jl","page":"Buchberger","title":"Buchberger.jl","text":"","category":"section"},{"location":"Buchberger.html","page":"Buchberger","title":"Buchberger","text":"Documentation for Buchberger.jl","category":"page"},{"location":"Buchberger.html","page":"Buchberger","title":"Buchberger","text":"Modules = [IPGBs.Buchberger]","category":"page"},{"location":"Buchberger.html#IPGBs.Buchberger","page":"Buchberger","title":"IPGBs.Buchberger","text":"Implements a combinatorial Buchberger algorithm for Integer Programming where all data is non-negative. Based on Thomas and Weismantel (1997).\n\n\n\n\n\n","category":"module"},{"location":"Buchberger.html#IPGBs.Buchberger.BuchbergerState","page":"Buchberger","title":"IPGBs.Buchberger.BuchbergerState","text":"The state of Buchberger S-binomial generation.\n\n\n\n\n\n","category":"type"},{"location":"Buchberger.html#IPGBs.Buchberger.next_state!-Tuple{IPGBs.Buchberger.BuchbergerState}","page":"Buchberger","title":"IPGBs.Buchberger.next_state!","text":"Updates the state to the indices of the next generated S-pair. Returns the indices of the new state, if it corresponds to a new S-pair, or nothing, if all S-pairs were already generated.\n\n\n\n\n\n","category":"method"},{"location":"Buchberger.html#IPGBs.GBAlgorithms.late_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.Buchberger.BuchbergerAlgorithm{T}, IPGBs.GBElements.CriticalPair}} where T<:IPGBs.GBElements.GBElement","page":"Buchberger","title":"IPGBs.GBAlgorithms.late_pair_elimination","text":"Applies the GCD criterion to determine whether or not to eliminate the given S-pair.\n\n\n\n\n\n","category":"method"},{"location":"Buchberger.html#IPGBs.GBAlgorithms.next_pair!-Union{Tuple{IPGBs.Buchberger.BuchbergerAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"Buchberger","title":"IPGBs.GBAlgorithms.next_pair!","text":"Produces the next BinomialPair to be processed by the Buchberger algorithm, if one exists, or nothing otherwise.\n\nAuto-reduces the partial GB periodically (for consistency with 4ti2).\n\n\n\n\n\n","category":"method"},{"location":"Statistics.html#Statistics.jl","page":"Statistics","title":"Statistics.jl","text":"","category":"section"},{"location":"Statistics.html","page":"Statistics","title":"Statistics","text":"Documentation for Statistics.jl","category":"page"},{"location":"Statistics.html","page":"Statistics","title":"Statistics","text":"Modules = [IPGBs.Statistics]","category":"page"},{"location":"SolverTools.html#SolverTools.jl","page":"SolverTools","title":"SolverTools.jl","text":"","category":"section"},{"location":"SolverTools.html","page":"SolverTools","title":"SolverTools","text":"Documentation for SolverTools.jl","category":"page"},{"location":"SolverTools.html","page":"SolverTools","title":"SolverTools","text":"Modules = [IPGBs.SolverTools]","category":"page"},{"location":"SolverTools.html#IPGBs.SolverTools","page":"SolverTools","title":"IPGBs.SolverTools","text":"Includes various LP and IP functions using external solvers and JuMP.\n\n\n\n\n\n","category":"module"},{"location":"SolverTools.html#IPGBs.SolverTools.bounded_objective-Tuple{Matrix{Int64}, Int64, Vector{Int64}}","page":"SolverTools","title":"IPGBs.SolverTools.bounded_objective","text":"bounded_objective(A :: Matrix{Int}, i :: Int, sigma :: Vector{Int})\n\nCompute the objective function for the bounded case of the project-and-lift algorithm.\n\nBy Farkas Lemma, either A^σ x^σ + Aσ xσ = 0 has a solution with b^T x < 0 or y^T A^σ <= (b^σ)^T y^T Aσ == bσ^T has a solution. In this case of P&L, the latter holds and if y is a solution it follows that c = b - A^T y satisfies: cσ = 0 and c^T u = -ui for all u in ker(A).\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.feasibility_model-Tuple{Matrix{Int64}, Vector{Int64}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}, DataType}","page":"SolverTools","title":"IPGBs.SolverTools.feasibility_model","text":"feasibility_model(A :: Matrix{Int}, b :: Vector{Int}, u :: Vector{<: Union{Int, Nothing}}, nonnegative :: Vector{Bool}, var_type :: DataType)\n\nReturn a feasibility checking model along with variable and constraint vectors for Ax = b, 0 <= x <= u, where x is either an integer variable vector, if var_type == Int or a real variable vector otherwise.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_bounded-Tuple{Int64, JuMP.Model, Vector{JuMP.VariableRef}}","page":"SolverTools","title":"IPGBs.SolverTools.is_bounded","text":"is_bounded(i :: Int, model :: JuMP.Model, x :: Vector{JuMP.VariableRef})\n\nReturn true iff maximizing x_i in model is bounded (has an optimal solution).\n\nIt is assumed that the given model is (primal) feasible.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_bounded-Tuple{JuMP.Model}","page":"SolverTools","title":"IPGBs.SolverTools.is_bounded","text":"is_bounded(model :: JuMP.Model)\n\nReturn true iff the IP/LP given by model is feasible.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_degenerate-Tuple{JuMP.Model, Vector{JuMP.VariableRef}, Vector{JuMP.ConstraintRef}}","page":"SolverTools","title":"IPGBs.SolverTools.is_degenerate","text":"is_degenerate(model :: JuMP.Model, vars :: Vector{VariableRef}, constraints :: Vector{ConstraintRef})\n\nReturn true iff the optimal basis of model is degenerate, i.e. if any of its basic variables has value 0.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_feasible-Tuple{JuMP.Model}","page":"SolverTools","title":"IPGBs.SolverTools.is_feasible","text":"is_feasible(model :: JuMP.Model)\n\nReturn true iff the IP/LP given by model is feasible.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.jump_model-Tuple{Matrix{Int64}, Vector{Int64}, Array{Float64}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}, DataType}","page":"SolverTools","title":"IPGBs.SolverTools.jump_model","text":"jump_model(A :: Matrix{Int}, b :: Vector{Int}, C :: Array{Float64}, u :: Vector{Union{Int, Nothing}}, nonnegative :: Vector{Bool}, var_type :: DataType)\n\nReturn a JuMP model (alongside references to its variables and constraints) for the given IP or LP problem.\n\nThe optimization problem considered is min c[1, :] * x s.t. Ax = b, x_i >= 0 for all i s.t. nonnegative[i] == true\n\nThe variables are integer if var_type == Int or real otherwise.\n\nTODO Should I do anything special for the binary case?\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.optimal_basis!-Tuple{JuMP.Model}","page":"SolverTools","title":"IPGBs.SolverTools.optimal_basis!","text":"optimal_basis!(model :: JuMP.Model) :: Vector{Bool}\n\nReturn a boolean vector with value true at index i iff the i-th variable is basic at the optimal solution of model.\n\nThis function calls optimize! on model in order to be self-contained.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.optimal_row_span-Union{Tuple{T}, Tuple{Matrix{Int64}, Vector{Int64}, Array{T}}, Tuple{Matrix{Int64}, Vector{Int64}, Array{T}, Symbol}} where T<:Real","page":"SolverTools","title":"IPGBs.SolverTools.optimal_row_span","text":"optimal_row_span(A :: Matrix{Int}, b :: Vector{Int}, c :: Array{T}) where {T <: Real}\n\nCompute a vector in the row span of A given by yA where y is the optimal solution to the dual of the LP given by A, b, c.\n\nAssumes Ax = b is feasible, and max x s.t. Ax = b, x >= 0 is bounded. Given these conditions, the dual variables of the constraints of the above LP give a positive row span vector.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.positive_row_span-Tuple{Matrix{Int64}, Vector{Int64}}","page":"SolverTools","title":"IPGBs.SolverTools.positive_row_span","text":"positive_row_span(A :: Matrix{Int}, b :: Vector{Int})\n\nCompute a strictly positive vector in the row span of A using linear programming.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.relaxation_model-Tuple{Matrix{Int64}, Vector{Int64}, Array{Float64}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}}","page":"SolverTools","title":"IPGBs.SolverTools.relaxation_model","text":"relaxation_model(A :: Matrix{Int}, b :: Vector{Int}, C :: Array{Float64}, u :: Vector{Union{Int, Nothing}}, nonnegative :: Vector{Bool})\n\nReturn a linear relaxation model of the given IP.\n\nThe optimization problem considered is of the form min C[1, :]' * x s.t. Ax = b, x >= 0.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.set_jump_objective!-Union{Tuple{T}, Tuple{JuMP.Model, Symbol, Vector{T}, Vector{JuMP.VariableRef}}} where T<:Real","page":"SolverTools","title":"IPGBs.SolverTools.set_jump_objective!","text":"set_jump_objective!(model :: JuMP.Model, direction :: Symbol, c :: Vector{T}, x :: Vector{JuMP.VariableRef}) where {T <: Real}\n\nUpdates model changing its objective function to c and sense to direction, which can be either :Max or :Min.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.unboundedness_ip_model-Tuple{Matrix{Int64}, Vector{Bool}, Int64}","page":"SolverTools","title":"IPGBs.SolverTools.unboundedness_ip_model","text":"unboundedness_ip_model(A :: Matrix{Int}, nonnegative :: Vector{Bool}, i :: Int)\n\nReturn an IP that checks for the existence of an integer vector u such that Au = 0, u[nonnegative] >= 0, u[i] > 0.\n\nTODO this could also be done with LP as follows: \"Assume all data is rational. Then, the polyhedron is rational, so the optimum must be rational. Multiply by a large enough integer...\" Implement it this way later!\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.update_feasibility_model_rhs-Union{Tuple{T}, Tuple{Vector{JuMP.ConstraintRef}, Matrix{Int64}, Vector{Int64}, T}} where T<:AbstractVector{Int64}","page":"SolverTools","title":"IPGBs.SolverTools.update_feasibility_model_rhs","text":"update_feasibility_model_rhs(constraints :: Vector{ConstraintRef}, A :: Matrix{Int}, b :: Vector{Int}, v :: T) where {T <: AbstractVector{Int}}\n\nChange the RHS of constraints to b - A * v.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#SupportTrees.jl","page":"SupportTrees","title":"SupportTrees.jl","text":"","category":"section"},{"location":"SupportTrees.html","page":"SupportTrees","title":"SupportTrees","text":"Documentation for SupportTrees.jl","category":"page"},{"location":"SupportTrees.html","page":"SupportTrees","title":"SupportTrees","text":"Modules = [IPGBs.SupportTrees]","category":"page"},{"location":"SupportTrees.html#IPGBs.SupportTrees","page":"SupportTrees","title":"IPGBs.SupportTrees","text":"Reimplementation of 4ti2's FilterReduction tree structure used to store binomial sets for efficient reductions. Called SupportTrees in reference to Roune and Stillman (2012).\n\n\n\n\n\n","category":"module"},{"location":"SupportTrees.html#IPGBs.SupportTrees.SupportNode","page":"SupportTrees","title":"IPGBs.SupportTrees.SupportNode","text":"Each binomial in the GB is inserted in some node of the tree.\n\nA filter is a list of indices of the binomials such that their coordinates are positive - that is, the list of indices of variables appearing in its leading term.\n\nA binomial is inserted in a node of the tree with the same filter as itself. All binomials with the same filter are inserted in the same node. If the tree corresponds to a GB (or a partial GB in some way) each node should contain at most one binomial in its binomial_list.\n\nEach child node is labeled by its (next) filter index.\n\n\n\n\n\n","category":"type"},{"location":"SupportTrees.html#IPGBs.SupportTrees.SupportTree","page":"SupportTrees","title":"IPGBs.SupportTrees.SupportTree","text":"The structure from 4ti2's FilterReduction for efficient reduction of binomials in toric ideals.\n\nAt each level i of the tree, there exists a node labeled j if there is some binomial in the tree whose filter's i-th element is j. Each binomial is stored at level n, with n the size of its filter.\n\nIf fullfilter is true, then both positive and negative entries of the binomials are considered to be in the filter for reduction. This is useful to implement the specialized truncated GB algorithm described in Thomas and Weismantel, Section 3.\n\n\n\n\n\n","category":"type"},{"location":"SupportTrees.html#IPGBs.SupportTrees.addbinomial!-Union{Tuple{T}, Tuple{IPGBs.SupportTrees.SupportTree{T}, T}} where T<:AbstractVector{Int64}","page":"SupportTrees","title":"IPGBs.SupportTrees.addbinomial!","text":"Adds a (reference to a) binomial to a SupportTree.\n\nThe idea is adding the binomial to a node corresponding precisely to its filter. At each iteration, take the i-th element of the filter of binomial. If there is already a node in the tree at level i labeled by the i-th index in the filter of binomial, move to the subtree defined by that node. Otherwise, create such a node.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.enumerate_reducers!-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{Vector{T}, P, S, IPGBs.SupportTrees.SupportNode{T}}} where {P<:AbstractVector{Int64}, T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.enumerate_reducers!","text":"Walks in the tree recursively pushing any reducers found to reducers.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.enumerate_reducers-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{P, S, IPGBs.SupportTrees.SupportTree{T}}} where {P<:AbstractVector{Int64}, T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.enumerate_reducers","text":"Returns a vector containing all reducers of g in gb, using tree to find them efficiently.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.find_reducer-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.SupportNode{T}, IPGBs.SupportTrees.TreeStats}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.find_reducer","text":"Checks whether g is reducible by some element of gb and, if so, returns a reducer. Otherwise, returns nothing.\n\nThis is done by looking up a node in this subtree with a subfilter of g's filter and then checking directly whether some binomial in the node reduces g.\n\nThe lookup operation traverses the tree looking for nodes whose labels are contained in the filter of g.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.find_reducer-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.SupportTree{T}}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.find_reducer","text":"Checks whether g is reducible by some element of gb and, if so, returns a reducer. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.find_reducer_iter-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.SupportTree{T}}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.find_reducer_iter","text":"Finds a reducer of g in tree by searching the tree iteratively, instead of recursively. It serves as an alternative to find_reducer, although the performance is currently nearly equivalent.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.removebinomial!-Union{Tuple{T}, Tuple{IPGBs.SupportTrees.SupportTree{T}, T}} where T<:AbstractVector{Int64}","page":"SupportTrees","title":"IPGBs.SupportTrees.removebinomial!","text":"Removes binomial from tree by doing a lookup operation and then just removes it from the corresponding binomial_list.\n\nIf binomial is not in tree, nothing will happen.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.support_tree-Union{Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.support_tree","text":"Puts references to the elements of gb in a reduction tree, so that one may easily find whether a given binomial can be reduced by gb.\n\n\n\n\n\n","category":"method"},{"location":"GBTools.html#GBTools.jl","page":"GBTools","title":"GBTools.jl","text":"","category":"section"},{"location":"GBTools.html","page":"GBTools","title":"GBTools","text":"Documentation for GBTools.jl","category":"page"},{"location":"GBTools.html","page":"GBTools","title":"GBTools","text":"Modules = [IPGBs.GBTools]","category":"page"},{"location":"GBTools.html#IPGBs.GBTools.grevlex_matrix-Tuple{Int64}","page":"GBTools","title":"IPGBs.GBTools.grevlex_matrix","text":"Returns a matrix representing the grevlex order for n variables with xn > x{n-1} > ... > x_1\n\n\n\n\n\n","category":"method"},{"location":"GBTools.html#IPGBs.GBTools.lex_matrix-Tuple{Int64}","page":"GBTools","title":"IPGBs.GBTools.lex_matrix","text":"Returns a matrix representing the lex order for n variables with x1 > x2 > ... > x_n.\n\n\n\n\n\n","category":"method"},{"location":"GBTools.html#IPGBs.GBTools.revlex_matrix-Tuple{Int64}","page":"GBTools","title":"IPGBs.GBTools.revlex_matrix","text":"Returns a matrix representing the lex order for n variables with x1 < x2 < ... < x_n.\n\nThis is the tiebreaking order used by 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#SignatureAlgorithms.jl","page":"SignatureAlgorithms","title":"SignatureAlgorithms.jl","text":"","category":"section"},{"location":"SignatureAlgorithms.html","page":"SignatureAlgorithms","title":"SignatureAlgorithms","text":"Documentation for SignatureAlgorithms.jl","category":"page"},{"location":"SignatureAlgorithms.html","page":"SignatureAlgorithms","title":"SignatureAlgorithms","text":"Modules = [IPGBs.SignatureAlgorithms]","category":"page"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms","text":"An implementation of a Signature-based algorithm for Gröbner bases of toric ideals.\n\n\n\n\n\n","category":"module"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.SignatureSet","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.SignatureSet","text":"Stores one SupportTree for each signature index. This enables fast divisor queries for Signatures.\n\n\n\n\n\n","category":"type"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.initialize!-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, Matrix{Int64}, Vector{Int64}, Matrix{Float64}, Vector{Int64}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.initialize!","text":"Initializes all data in algorithm. Must be called before using any of the data inside for GB computations.\n\nTODO almost all of this logic is still duplicated in Buchberger.jl. Can I do #this better?\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.late_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.late_pair_elimination","text":"Attempts to eliminate pair before building it as an explicit GBElement, after retrieving it from the priority queue for processing.\n\nReturns true iff pair may be eliminated at this point.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.next_pair!-Union{Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.next_pair!","text":"Generates the next pair to be processed by algorithm by picking the first element of its priority queue. Returns nothing if there are no more S-pairs to be processed and the algorithm may thus terminate.\n\nPairs are processed in order of increasing signature.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.process_zero_reduction!-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.process_zero_reduction!","text":"Adds syzygy_element to the set of known syzygies of algorithm.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.update!-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SigPoly{T}}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SigPoly{T}, Union{Nothing, IPGBs.SignaturePolynomials.SignaturePair}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.update!","text":"Adds the element g to the current basis maintained by algorithm. Uses pair, if available, to generate new Koszul syzygies. pair is assumed to be the SignaturePair that was used to generate g.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.base_divisors_criterion-Union{Tuple{T}, Tuple{Int64, Int64, Int64, Union{Nothing, IPGBs.SignatureAlgorithms.LowBaseDiv}, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.base_divisors_criterion","text":"Applies the Base Divisors Criterion presented in Roune and Stillman (2012).\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.divided_by-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignatureAlgorithms.SignatureSet}","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.divided_by","text":"Returns true iff there is a signature in signatures that divides s. Uses SupportTrees for efficient divisor search.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.early_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.early_pair_elimination","text":"Attempts to eliminate pair before putting it into the priority queue, but after computing its signature.\n\nReturns true iff pair may be eliminated at this point.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.enumerate_divisors-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignatureAlgorithms.SignatureSet}","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.enumerate_divisors","text":"Returns a list of all divisors of s in signatures that are distinct from s.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.high_base_divisor-Union{Tuple{T}, Tuple{Int64, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.high_base_divisor","text":"Computes the index of the best high-ratio base divisor for the element of index j.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.high_base_divisors_criterion-Union{Tuple{T}, Tuple{Int64, Int64, Int64, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.high_base_divisors_criterion","text":"The Base divisor criterion for high-ratio elements. An element a is high-ratio if lt(a) | lt(b), where b is the new element being added.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.koszul_criterion-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SignaturePair, DataStructures.BinaryHeap{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.koszul_criterion","text":"Applies the Koszul criterion to spair, returning true iff it can be eliminated by this criterion. The main idea is checking whether there exists a regular Koszul syzygy with the same signature as spair. If this happens, spair may be eliminated.\n\nTODO this isn't eliminating pretty much anything at all! Investigate\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.low_base_divisors_criterion-Union{Tuple{T}, Tuple{Int64, Int64, Union{Nothing, IPGBs.SignatureAlgorithms.LowBaseDiv}, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.low_base_divisors_criterion","text":"The Base divisor criterion for low-ratio elements. An element a is low-ratio if signature(a) | signature(b), where b is the new element being added.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.signature_criterion-Tuple{IPGBs.SignaturePolynomials.SignaturePair, IPGBs.SignatureAlgorithms.SignatureSet}","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.signature_criterion","text":"Returns true iff spair is eliminated by the signature criterion, i.e. there is a known syzygy that divides its signature.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.update_queue!-Union{Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.update_queue!","text":"Adds new SignaturePairs to algorithm.heap. Applies early elimination of S-pairs when possible.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.update_syzygies!-Union{Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.update_syzygies!","text":"Adds the Koszul syzygies corresponding to the newest element of gb to the syzygy list.\n\nCurrently unused, as this is inefficient. It's not necessary to add all Koszul syzygies.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.very_early_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, Int64, Union{Nothing, IPGBs.SignatureAlgorithms.LowBaseDiv}, Int64, Int64}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.very_early_pair_elimination","text":"Attempts to eliminate the pair (i, j) before even creating it as a SignaturePair (thus, without computing its signature).\n\nReturns true iff (i, j) may be eliminated at this point.\n\n\n\n\n\n","category":"method"},{"location":"MonomialHeaps.html#MonomialHeaps.jl","page":"MonomialHeaps","title":"MonomialHeaps.jl","text":"","category":"section"},{"location":"MonomialHeaps.html","page":"MonomialHeaps","title":"MonomialHeaps","text":"Documentation for MonomialHeaps.jl","category":"page"},{"location":"MonomialHeaps.html","page":"MonomialHeaps","title":"MonomialHeaps","text":"Modules = [IPGBs.MonomialHeaps]","category":"page"},{"location":"MonomialHeaps.html#IPGBs.MonomialHeaps.MonomialHeap","page":"MonomialHeaps","title":"IPGBs.MonomialHeaps.MonomialHeap","text":"Keeps a priority list / heap of monomials, ordered by weight, without repetitions. The number of times any monomial is inserted is stored in the WeightedMonomial structure.\n\n\n\n\n\n","category":"type"},{"location":"MonomialHeaps.html#IPGBs.MonomialHeaps.WeightedMonomial","page":"MonomialHeaps","title":"IPGBs.MonomialHeaps.WeightedMonomial","text":"Monomial with weight given by a monomial order, used for fast comparison in a priority queue or heap. It also includes a count to keep track of how many times this monomial has been generated. FGLM can use this to check whether some monomial is underneath a GB staircase efficiently.\n\n\n\n\n\n","category":"type"},{"location":"IPGBs.html#IPGBs.jl","page":"IPGBs","title":"IPGBs.jl","text":"","category":"section"},{"location":"IPGBs.html","page":"IPGBs","title":"IPGBs","text":"Documentation for IPGBs.jl","category":"page"},{"location":"IPGBs.html","page":"IPGBs","title":"IPGBs","text":"Modules = [IPGBs]","category":"page"},{"location":"IPGBs.html#IPGBs.groebner_basis-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPGBs","title":"IPGBs.groebner_basis","text":"Computes a Markov basis for instance and then uses it to compute a Gröbner basis.\n\n\n\n\n\n","category":"method"},{"location":"IPGBs.html#IPGBs.groebner_basis-Tuple{JuMP.Model}","page":"IPGBs","title":"IPGBs.groebner_basis","text":"Computes a Markov basis for instance and then uses it to compute a Gröbner basis.\n\n\n\n\n\n","category":"method"},{"location":"IPGBs.html#IPGBs.groebner_basis-Tuple{Vector{Vector{Int64}}, IPGBs.IPInstances.IPInstance}","page":"IPGBs","title":"IPGBs.groebner_basis","text":"TODO write full documentation for this top-level function...\n\nTODO as the number of arguments and complexity of preprocessing goes up, that should probably be done in another module\n\nmodule_order is one of :ltpot, :pot and :top. Only relevant for signature\n\nalgorithms\n\ntruncation type is one of :None, :Heuristic, :LP, :IP, :Simple\n\n\n\n\n\n","category":"method"},{"location":"IPGBs.html#IPGBs.groebner_basis-Union{Tuple{T}, Tuple{Matrix{Int64}, Vector{Int64}, Matrix{T}, Vector{Int64}}} where T<:Real","page":"IPGBs","title":"IPGBs.groebner_basis","text":"Computes a Markov basis for instance and then uses it to compute a Gröbner basis.\n\n\n\n\n\n","category":"method"},{"location":"IPGBs.html#IPGBs.use_simple_truncation-Tuple{Matrix{Int64}, Vector{Int64}}","page":"IPGBs","title":"IPGBs.use_simple_truncation","text":"Simple truncation works when the data in A, b are all non-negative. This is more efficient than IP truncation, and is exact, contrary to LP truncation, so it should be used whenever possible.\n\nThis function returns whether simple truncation can be used.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Documentation-for-the-IPGBs-project","page":"Documentation for the IPGBs project","title":"Documentation for the IPGBs project","text":"","category":"section"},{"location":"index.html","page":"Documentation for the IPGBs project","title":"Documentation for the IPGBs project","text":"","category":"page"},{"location":"index.html#Index","page":"Documentation for the IPGBs project","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Documentation for the IPGBs project","title":"Documentation for the IPGBs project","text":"","category":"page"}]
}
