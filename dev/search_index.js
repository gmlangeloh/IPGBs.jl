var documenterSearchIndex = {"docs":
[{"location":"TriangleHeaps.html#TriangleHeaps.jl","page":"TriangleHeaps","title":"TriangleHeaps.jl","text":"","category":"section"},{"location":"TriangleHeaps.html","page":"TriangleHeaps","title":"TriangleHeaps","text":"Documentation for TriangleHeaps.jl","category":"page"},{"location":"TriangleHeaps.html","page":"TriangleHeaps","title":"TriangleHeaps","text":"Modules = [IPGBs.TriangleHeaps]","category":"page"},{"location":"TriangleHeaps.html#IPGBs.TriangleHeaps","page":"TriangleHeaps","title":"IPGBs.TriangleHeaps","text":"Implements the S-pair triangles described in Roune and Stillman (2012), Section 4.3.\n\n\n\n\n\n","category":"module"},{"location":"TriangleHeaps.html#IPGBs.TriangleHeaps.TriangleHeap","page":"TriangleHeaps","title":"IPGBs.TriangleHeaps.TriangleHeap","text":"Stores a heap of SignaturePairs (i, j) containing only the S-pair of smallest signature for each i. Then, for each i, a row of triangle contains all the values of j such that (i, j) is still in the queue, without storing the signatures of these S-pairs. This reduces memory consumption.\n\nFor further improvements in memory consumption, we use the type parameter I to allow for smaller unsigned integer types. Using Uint16 allows computing with GBs of up to 65535 elements.\n\n\n\n\n\n","category":"type"},{"location":"TriangleHeaps.html#Base.isempty-Union{Tuple{IPGBs.TriangleHeaps.TriangleHeap{T, I}}, Tuple{I}, Tuple{T}} where {T, I}","page":"TriangleHeaps","title":"Base.isempty","text":"Returns true iff heap is empty. Just delegates to its internal heap, which is only empty when heap is.\n\n\n\n\n\n","category":"method"},{"location":"TriangleHeaps.html#Base.pop!-Union{Tuple{IPGBs.TriangleHeaps.TriangleHeap{T, I}}, Tuple{I}, Tuple{T}} where {T, I}","page":"TriangleHeaps","title":"Base.pop!","text":"Returns the SignaturePair of lowest signature in heap. Assumes that heap is non-empty.\n\n\n\n\n\n","category":"method"},{"location":"TriangleHeaps.html#IPGBs.TriangleHeaps.push_batch!-Union{Tuple{I}, Tuple{T}, Tuple{IPGBs.TriangleHeaps.TriangleHeap{T, I}, Vector{IPGBs.SignaturePolynomials.SignaturePair}}} where {T, I}","page":"TriangleHeaps","title":"IPGBs.TriangleHeaps.push_batch!","text":"Puts a batch of SignaturePairs (all coming from pairs (i, j) with fixed j) in heap, adding a new row to its triangle. Has to sort the S-pairs by signature, so its complexity is O(S * n log n) where S is the complexity of signature comparison and n = length(batch).\n\n\n\n\n\n","category":"method"},{"location":"FeasibleGraphs.html#FeasibleGraphs.jl","page":"FeasibleGraphs","title":"FeasibleGraphs.jl","text":"","category":"section"},{"location":"FeasibleGraphs.html","page":"FeasibleGraphs","title":"FeasibleGraphs","text":"Documentation for FeasibleGraphs.jl","category":"page"},{"location":"FeasibleGraphs.html","page":"FeasibleGraphs","title":"FeasibleGraphs","text":"Modules = [IPGBs.FeasibleGraphs]","category":"page"},{"location":"GBElements.html#GBElements.jl","page":"GBElements","title":"GBElements.jl","text":"","category":"section"},{"location":"GBElements.html","page":"GBElements","title":"GBElements","text":"Documentation for GBElements.jl","category":"page"},{"location":"GBElements.html","page":"GBElements","title":"GBElements","text":"Modules = [IPGBs.GBElements]","category":"page"},{"location":"GBElements.html#IPGBs.GBElements","page":"GBElements","title":"IPGBs.GBElements","text":"This module defines all the binomial data structures used in my implementations of Buchberger's algorithm and Signature-based algorithms.\n\nTODO: make GBElements a consistent interface\n\n\n\n\n\n","category":"module"},{"location":"GBElements.html#IPGBs.GBElements.GBElement","page":"GBElements","title":"IPGBs.GBElements.GBElement","text":"Abstract type used for GB computations. It is meant to generalize both binomials and binomials with signature, in order to simplify the implementation of reduction algorithms.\n\n\n\n\n\n","category":"type"},{"location":"GBElements.html#IPGBs.GBElements.degree_reducible-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.degree_reducible","text":"This is only relevant when we consider the implicit representation of binomials. For this explicit representation, we can always return true.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.filter-Tuple{T} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.filter","text":"filter(\nbinomial :: T;\nfullfilter :: Bool = false\n\n) :: Vector{Int} where {T <: AbstractVector{Int}}\n\nThe filter of a binomial, that is, the list of indices of variables appearing in its leading term.\n\nIf fullfilter = true, include the indices of variables appearing in its trailing term.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.head-Tuple{IPGBs.GBElements.GBElement}","page":"GBElements","title":"IPGBs.GBElements.head","text":"The indices of the positive support of g. Or indices of the support of leading_term(g)\n\nTODO: could probably turn this into an iterator instead, would be more efficient\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.ipgbs_form-Tuple{Matrix{Int64}}","page":"GBElements","title":"IPGBs.GBElements.ipgbs_form","text":"Turns a 4ti2 GB into my GB format as a vector of integer vectors.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.is_negative_disjoint-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.is_negative_disjoint","text":"Checks whether the trailing terms of g and h are disjoint. In case negative = true, checks whether the leading term of g is disjoint with the trailing term of h.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.is_zero-Tuple{T} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.is_zero","text":"Returns true iff this binomial is zero, that is, all of its coordinates are 0.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.le_coordinatewise-Tuple{Vector{Int64}, Vector{Int64}}","page":"GBElements","title":"IPGBs.GBElements.le_coordinatewise","text":"Returns true iff v1 <= v2 coordinate-wise.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.le_upperbound-Union{Tuple{T}, Tuple{T, Vector{Union{Nothing, Int64}}}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.le_upperbound","text":"Checks whether v is bounded coordinate by coordinate by u.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.leading_term-Tuple{T} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.leading_term","text":"Computes the leading term of this GBElement as a vector.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.model_truncation-Union{Tuple{T}, Tuple{T, Matrix{Int64}, Vector{Int64}, JuMP.Model, Vector{JuMP.ConstraintRef}}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.model_truncation","text":"Checks feasibility of:\n\nAx = b - Av 0 <= x <= u\n\nwith x either a vector of real variables or integer variables, whatever is defined in model. In order to do this efficiently, updates the RHS of the previously built model by modifying constraints.\n\nReturns true iff v is feasible for the above model, which means it should NOT be truncated.\n\nTODO: LP truncation is slightly slower than I hoped. IP truncation is very slow. Can I implement the model more efficiently somehow?\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.monomial_quotient-Union{Tuple{T}, Tuple{T, T}} where T<:IPGBs.GBElements.GBElement","page":"GBElements","title":"IPGBs.GBElements.monomial_quotient","text":"monomial_quotient(\nbinomial :: T,\nreducer :: T\n\n) :: Vector{Int} where {T <: GBElement}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.reduce!-Union{Tuple{T}, Tuple{T, T, IPGBs.Orders.GBOrder}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.reduce!","text":"Reduce binomial by reducer as many times as possible. Assumes reducer reduces binomial at least once.\n\nReturns true iff binomial reduced to 0.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.reduces-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{P, Vector{Int64}, T, S}} where {P<:AbstractVector{Int64}, T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"GBElements","title":"IPGBs.GBElements.reduces","text":"reduces(\ng :: P,\nfilter :: Vector{Int},\nreducer :: T,\ngb :: S;\nfullfilter :: Bool = true,\nnegative :: Bool = false,\nis_singular :: Ref{Bool} = Ref(false)\n\n) :: Bool where {P <: AbstractVector{Int}, T <: AbstractVector{Int}, S <: AbstractVector{T}}\n\nChecks whether reducer divides g, using the filter of reducer for efficiency. When fullfilter = true, checks if g.head >= reducer.head and g.tail >= reducer.tail coordinate-wise, while also checking a degree criterion.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.reduction_factor-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.reduction_factor","text":"reduction_factor(\nbinomial :: T,\nreducer :: T;\nnegative :: Bool = false\n\n) :: Int where {T <: AbstractVector{Int}}\n\nFinds the maximum k such that k * reducer <= binomial coordinate-wise.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.simple_truncation-Union{Tuple{T}, Tuple{T, Matrix{Int64}, Vector{Int64}, Vector{Union{Nothing, Int64}}}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.simple_truncation","text":"Returns true iff v should be considered for reduction in a truncated GB algorithm.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.supports-Tuple{AbstractVector{Int64}}","page":"GBElements","title":"IPGBs.GBElements.supports","text":"Computes bitsets with positive and negative supports of g.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.to_gbelement-Union{Tuple{T}, Tuple{Vector{Int64}, T, DataType}, Tuple{Vector{Int64}, T, DataType, Bool}} where T<:IPGBs.Orders.GBOrder","page":"GBElements","title":"IPGBs.GBElements.to_gbelement","text":"Turns a vector v into a GBElement of type S. Currently, Binomials are the only subtype supported.\n\n\n\n\n\n","category":"method"},{"location":"GBElements.html#IPGBs.GBElements.truncate-Union{Tuple{T}, Tuple{T, Matrix{Int64}, Vector{Int64}, Vector{Union{Nothing, Int64}}, JuMP.Model, Vector{JuMP.ConstraintRef}, Bool, Symbol}} where T<:AbstractVector{Int64}","page":"GBElements","title":"IPGBs.GBElements.truncate","text":"Returns true iff binomial should be truncated according to the given truncation_type.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#BinomialSets.jl","page":"BinomialSets","title":"BinomialSets.jl","text":"","category":"section"},{"location":"BinomialSets.html","page":"BinomialSets","title":"BinomialSets","text":"Documentation for BinomialSets.jl","category":"page"},{"location":"BinomialSets.html","page":"BinomialSets","title":"BinomialSets","text":"Modules = [IPGBs.BinomialSets]","category":"page"},{"location":"BinomialSets.html#IPGBs.BinomialSets.BinomialSet","page":"BinomialSets","title":"IPGBs.BinomialSets.BinomialSet","text":"Represents a set of binomials (e.g. a partial or complete Gröbner Basis), including structures for efficient reduction of elements.\n\nIn order to allow 4ti2-form bases, we allow elements to be Vector{Int}, in addition to GBElements.\n\n\n\n\n\n","category":"type"},{"location":"BinomialSets.html#IPGBs.BinomialSets.change_ordering!-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, Matrix{Float64}, Matrix{Int64}, Vector{Int64}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.change_ordering!","text":"Changes the ordering of bs to a monomial order given by the matrix new_order.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.fourti2_form-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.fourti2_form","text":"Returns the binomials of bs as integer vectors in minimization form.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_groebner_basis-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_groebner_basis","text":"Returns true iff bs is a Gröbner Basis. This is checked by applying Buchberger's theorem and generating all S-binomials, thus may be slow. Note that this verifies if bs is a Gröbner Basis, but not a truncated Gröbner Basis. To check the latter case, use istruncatedgroebner_basis.\n\nUseful for debugging and automatic tests.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_support_reducible-Union{Tuple{S}, Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_support_reducible","text":"Returns true if (i, j) should be discarded.\n\nThis is an implementation of Criteria 1 and 2 from Malkin's thesis.\n\nCriterion 1 is simply the classical Buchberger GCD criterion. If the positive supports are disjoint (= GCD of the leading terms is 1) then the pair may be discarded.\n\nCriterion 2 is specific to homogeneous ideals (or just ideals coming from lattices?) Either way, if the negative supports are not disjoint (= GCD of trailing terms is not 1) then the pair may be discarded. This applies specifically to the bounded components (= variables) of the problem.\n\nI also added new criteria for binary variables. In this case, a pair (i, j) may be discarded if the positive binaries of i are disjoint from the negative binaries of j, and vice-versa. This is because in these cases the pair will generate some binomial with 2 or -2 in some coordinate. These are never necessary in a Gröbner basis.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.is_truncated_groebner_basis-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, Function}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.is_truncated_groebner_basis","text":"is_truncated_groebner_basis(\nbs :: BinomialSet{T, S},\ntruncate :: Function\n\n) :: Bool where {T <: AbstractVector{Int}, S <: GBOrder}\n\nReturns true if and only if bs is a truncated Gröbner Basis with truncation done using the truncate function.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.minimal_basis!-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.minimal_basis!","text":"Updates gb to a minimal Gröbner Basis.\n\nFor more info on minimal GBs, see Lemma 3 from Cox, Little, O'Shea Chapter 2.7. In summary, it shows that one can remove from a GB any g such that LT(g) is a multiple of LT(h), for h distinct from g in the GB.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduce!-Union{Tuple{S}, Tuple{T}, Tuple{T, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduce!","text":"Reduces g by bs efficiently using a Support Tree. Returns a pair of booleans (r, c) where r == true iff g reduced to zero, and c == true iff g was changed in this reduction.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduce!-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.ReductionTree{T}}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduce!","text":"Fully reduce binomial by gb in-place, finding its normal form. Uses tree to speed up the search for reducers. Returns a pair of booleans (r, c) where r == true iff g reduced to zero, and c == true iff g was changed in this reduction.\n\nbinomial can also be a monomial.\n\nIf reduction_count is given, the number of times each reducer was used in this reduction process is added to reduction_count. This greatly slows down execution, and is only meant for experimental purposes. The parameter should be set to nothing in practical runs.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduce!-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:AbstractVector{Int64}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduce!","text":"reduce!(\ng :: T,\nbs :: Vector{T}\n\n) :: Tuple{Bool, Bool} where {T <: AbstractVector{Int}}\n\nReduce `g` by `bs` inefficiently by linearly searching for a reducer.\nThis is useful for very small examples and debugging. For anything else,\nconsider making a BinomialSet and reducing using a SupportTree.\n\nReturn a tuple (r, c) where r == true iff `g` reduced to zero, and c == true\niff `g` was changed in this reduction.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.reduced_basis!-Union{Tuple{IPGBs.BinomialSets.BinomialSet{T, S}}, Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.reduced_basis!","text":"Updates gb to a reduced Gröbner Basis.\n\n\n\n\n\n","category":"method"},{"location":"BinomialSets.html#IPGBs.BinomialSets.sbinomial-Union{Tuple{S}, Tuple{T}, Tuple{Vector{Int64}, IPGBs.GBElements.CriticalPair, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T<:AbstractVector{Int64}, S<:IPGBs.Orders.GBOrder}","page":"BinomialSets","title":"IPGBs.BinomialSets.sbinomial","text":"Creates a concrete S-binomial from pair. In practice, this should only be called after we were unable to eliminate pair.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#FastComparator.jl","page":"FastComparator","title":"FastComparator.jl","text":"","category":"section"},{"location":"FastComparator.html","page":"FastComparator","title":"FastComparator","text":"Documentation for FastComparator.jl","category":"page"},{"location":"FastComparator.html","page":"FastComparator","title":"FastComparator","text":"Modules = [IPGBs.FastComparator]","category":"page"},{"location":"FastComparator.html#IPGBs.FastComparator","page":"FastComparator","title":"IPGBs.FastComparator","text":"Implements fast comparisons of complex objects by building a structure of integers representing them.\n\nTODO currently repeated elements give different magnitudes. This is not necessarily a problem yet, but I should fix that if it ever becomes a problem\n\n\n\n\n\n","category":"module"},{"location":"FastComparator.html#IPGBs.FastComparator.Comparator","page":"FastComparator","title":"IPGBs.FastComparator.Comparator","text":"A structure allowing for O(1) comparison of elements of data. Updating the structure with new elements of data can take up to O(n). This is done by associating an integer to each element of data, such that data[i] < data[j] iff magnitudes[i] < magnitudes[j].\n\nTODO Maybe it is possible to optimize insertion to O(log n). Think about it later.\n\n\n\n\n\n","category":"type"},{"location":"FastComparator.html#Base.Order.lt-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64, Int64}} where {T, F}","page":"FastComparator","title":"Base.Order.lt","text":"Returns true iff the element of index index1 is smaller than that of index index2 in comp.data. Uses Comparator logic for comparison in O(1).\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.build!-Tuple{Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"FastComparator","title":"IPGBs.FastComparator.build!","text":"Returns a vector of sorted permutation indices and integer magnitudes of elements of data in the range given by [-range, range].\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.check_increasing_property-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.check_increasing_property","text":"Checks whether comp satisfies the increasing property, i.e. its elements in the order given by comp.sorted_permutation are in increasing order\n\nThis is useful for testing and debugging.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.compare-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64, Int64}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.compare","text":"Returns :lt, :eq, :gt if the element indexed by index1 is smaller, equal or greater than the one indexed by index2 respectively. Uses Comparator logic for comparison in O(1).\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.find_position-Union{Tuple{F}, Tuple{T}, Tuple{T, IPGBs.FastComparator.Comparator{T, F}}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.find_position","text":"Do a binary search for element on the data of comp to find the position where it should be inserted.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.increase_range!-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.increase_range!","text":"Increases the comparator range for magnitudes by RANGEUPDATEFACTOR when possible. If this is not possible, simply increases it to the maximum range possible (full integers).\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.ith_element-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.ith_element","text":"Returns the i-th element of the (sorted) data in comp.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.magnitude-Tuple{Int64, Int64, Int64}","page":"FastComparator","title":"IPGBs.FastComparator.magnitude","text":"Computes the magnitude of the i-th smallest element out of n elements with the given range. The elements are equally spaced in the range.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.occupation_ratio-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.occupation_ratio","text":"Ratio of occupied slots in [-comp.range, comp.range]\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.rebuild!-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.rebuild!","text":"Increases range and rebuilds comp, equally spacing the magnitudes of the elements in the new increased range.\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.update!-Union{Tuple{IPGBs.FastComparator.Comparator{T, F}}, Tuple{F}, Tuple{T}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.update!","text":"Updates comp with the magnitudes and sorted positions of any new elements added to comp.data. May rebuild the whole structure whenever necessary.\n\nTODO is it possible to lower the complexity of this function from O(n) to O(log n) by avoiding the insertions in a vector? Maybe using some other kind of structure to store comp.sorted_permutation\n\n\n\n\n\n","category":"method"},{"location":"FastComparator.html#IPGBs.FastComparator.update_magnitude!-Union{Tuple{F}, Tuple{T}, Tuple{IPGBs.FastComparator.Comparator{T, F}, Int64}} where {T, F}","page":"FastComparator","title":"IPGBs.FastComparator.update_magnitude!","text":"Inserts the magnitude of the element of rank rank in the magnitude list of comp. May rebuild the whole structure if there are no available magnitudes.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#GradedBinomials.jl","page":"GradedBinomials","title":"GradedBinomials.jl","text":"","category":"section"},{"location":"GradedBinomials.html","page":"GradedBinomials","title":"GradedBinomials","text":"Documentation for GradedBinomials.jl","category":"page"},{"location":"GradedBinomials.html","page":"GradedBinomials","title":"GradedBinomials","text":"Modules = [IPGBs.GradedBinomials]","category":"page"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials","page":"GradedBinomials","title":"IPGBs.GradedBinomials","text":"A structure for efficient computation of truncated GBs of IPs where the data is positive, as described in Section 3 of Thomas and Weismantel (1997). This type of implicit representation of GB elements is also used in Urbaniak, Weismantel and Ziegler (1997).\n\nTODO there are multiple implementations of sparse subtraction of GradedBinomials here. I should probably check whether I need them all\n\nTODO Currently, using GradedBinomials gives different (but apparently correct) GBs than using Binomials. There's probably something implicit about the monomial order they're computed wrt that I'm missing, due to one being maximization and the other being minimization.\n\nRegardless, I'm unconvinced this will ever be more efficient than the usual Binomials. The main reason is that the implicit variables are updated and checked in the reduction process regardless, only this happens in a different way in the SupportTree. A slightly different implementation, where the implicit variables aren't stored anywhere and are computed as needed could be useful if memory became an issue, but that is another thing entirely.\n\n\n\n\n\n","category":"module"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.GradedBinomial","page":"GradedBinomials","title":"IPGBs.GradedBinomials.GradedBinomial","text":"Represents a binomial as a vector of integers, tracking its leading and trailing terms and degree for easy and efficient implementation of truncated GBs.\n\n\n\n\n\n","category":"type"},{"location":"GradedBinomials.html#Base.:--Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"Base.:-","text":"Subtracts two GradedBinomials, updating head/tail and cost. This is more efficient than just subtracting directly.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#Base.:--Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"Base.:-","text":"Unary minus for GradedBinomials. It swaps head by tail and inverts cost.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#Base.setindex!-Tuple{IPGBs.GradedBinomials.GradedBinomial, Int64, Int64}","page":"GradedBinomials","title":"Base.setindex!","text":"Sets g at index i to v. In theory, this shouldn't be used, as GradedBinomials should not be changed.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.degree_reducible-Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.degree_reducible","text":"Checks whether g.degree+ <= h.degree coordinate-wise, where g.degree+ is the set of positive subset of coordinates of g.degree.\n\nIf negative == true, checks whether g.degree- <= h.degree-\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.fullform-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.fullform","text":"Given g = v+ - v-, returns the full form of g including slack variables. This is given by: x^(v+) s^((Av)-) r^(v-)   -   x^(v-) s^((Av)+) r^(v+)\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.minus-Tuple{Vector{Int64}, IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.minus","text":"TODO do this in a memory-efficient way by reusing result\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.opposite!-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.opposite!","text":"In-place unary minus for GradedBinomials\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.reduce!-Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial, IPGBs.Orders.GBOrder}","page":"GradedBinomials","title":"IPGBs.GBElements.reduce!","text":"Computes g -= h in place.\n\nReturns true iff g reduced to zero.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GBElements.supports-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GBElements.supports","text":"Computes bitsets with the positive and negative supports of g.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.decomposition-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.decomposition","text":"Decomposes g = v+ - v-, where both v+ and v- are non-negative arrays.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.filter-Tuple{IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.filter","text":"Computes the filter of binomial. In case fullfilter == false, this is just the indices in the support of the leading term of binomial.\n\nOtherwise (fullfilter == true) this is the vector of ordered indices of the support of binomial, so it also includes indices in the trailing term.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.fourti2_form-Tuple{Vector{IPGBs.GradedBinomials.GradedBinomial}}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.fourti2_form","text":"Transforms a vector of GradedBinomials into the form of 4ti2 input/output. This includes putting GradedBinomials into fullform, including all of their variables which are implicit in the GradedBinomial structure.\n\nIf is_maximization is true, assumes the GradedBinomials are in maximization form. As 4ti2 assumes minimization, signs have to be swapped.\n\n\n\n\n\n","category":"method"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.lattice_generator_graded","page":"GradedBinomials","title":"IPGBs.GradedBinomials.lattice_generator_graded","text":"Vector in Z^n with i-th coordinate 1 and remaining coordinates 0.\n\n\n\n\n\n","category":"function"},{"location":"GradedBinomials.html#IPGBs.GradedBinomials.reduce_negative!-Tuple{IPGBs.GradedBinomials.GradedBinomial, IPGBs.GradedBinomials.GradedBinomial}","page":"GradedBinomials","title":"IPGBs.GradedBinomials.reduce_negative!","text":"Computes g = h - g changing g in-place. This is useful in the case g is supposed to be reduced by h but g.cost < h.cost.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#FGLM.jl","page":"FGLM","title":"FGLM.jl","text":"","category":"section"},{"location":"FGLM.html","page":"FGLM","title":"FGLM","text":"Documentation for FGLM.jl","category":"page"},{"location":"FGLM.html","page":"FGLM","title":"FGLM","text":"Modules = [IPGBs.FGLM]","category":"page"},{"location":"FGLM.html#IPGBs.FGLM.direct_normal_form-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.MonomialHeaps.WeightedMonomial, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.direct_normal_form","text":"direct_normal_form(m :: WeightedMonomial, gb :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}\n\nCompute the normal form of m with respect to gb by applying the usual reduction process directly.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.fast_normal_form-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.MonomialHeaps.WeightedMonomial, IPGBs.BinomialSets.BinomialSet{T, S}}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.fast_normal_form","text":"fast_normal_form(m :: WeightedMonomial, gb :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}\n\nCompute the normal form of m with respect to gb by computing NormalForm(xi * NormalForm(m')) where m = xi * m'.\n\nThis is the method suggested in the original FGLM paper Faugère et al (1994).\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.fglm-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.BinomialSets.BinomialSet{T, S}, S}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.fglm","text":"fglm(gb1 :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}\n\nConvert a Gröbner basis gb1 to target_order using the FGLM algorithm.\n\nFGLM only works when the ideal generated by gb1 is zero-dimensional. This is assumed in the implementation.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.find_linear_dependency-Tuple{Vector{Int64}, Dict{Vector{Int64}, Vector{Int64}}}","page":"FGLM","title":"IPGBs.FGLM.find_linear_dependency","text":"find_linear_dependency(nf :: Vector{Int}, std_basis :: Dict{Vector{Int}, Vector{Int}}\n\nReturn an element of std_basis with normal form nf, if such an element exists, otherwise return [].\n\nTODO It is likely possible to do this more efficient using some special kind of tree. I'll leave this for later, in case it's needed.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.is_below_staircase-Union{Tuple{T}, Tuple{IPGBs.MonomialHeaps.WeightedMonomial, Vector{T}}} where T","page":"FGLM","title":"IPGBs.FGLM.is_below_staircase","text":"is_below_staircase(m :: Vector{Int}, gb :: Vector{T}) where {T}\n\nChecks whether m is below the staircase given by gb. Naïve implementation. It is possible to do this more efficiently by counting the number of times FGLM generated m.\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.is_below_staircase_fast-Tuple{IPGBs.MonomialHeaps.WeightedMonomial}","page":"FGLM","title":"IPGBs.FGLM.is_below_staircase_fast","text":"is_below_staircase_fast(m :: WeightedMonomial)\n\nCheck whether m is below a GB staircase indirectly by counting how many times it was inserted in the priority queue.\n\nThis idea comes straight from the original FGLM paper Faugère et al (1994).\n\n\n\n\n\n","category":"method"},{"location":"FGLM.html#IPGBs.FGLM.update_monomial_heap!-Union{Tuple{S}, Tuple{T}, Tuple{IPGBs.MonomialHeaps.MonomialHeap{S}, IPGBs.MonomialHeaps.WeightedMonomial, T}} where {T, S<:IPGBs.Orders.GBOrder}","page":"FGLM","title":"IPGBs.FGLM.update_monomial_heap!","text":"update_monomial_heap!(h :: MonomialHeap{T}, m :: Vector{Int}) where {T <: GBOrder}\n\nAdd all monomials of the form xi * m for all variables xi to the heap h and count repetitions.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#FourTi2.jl","page":"FourTi2","title":"FourTi2.jl","text":"","category":"section"},{"location":"FourTi2.html","page":"FourTi2","title":"FourTi2","text":"Documentation for FourTi2.jl","category":"page"},{"location":"FourTi2.html","page":"FourTi2","title":"FourTi2","text":"Modules = [IPGBs.FourTi2]","category":"page"},{"location":"FourTi2.html#IPGBs.FourTi2","page":"FourTi2","title":"IPGBs.FourTi2","text":"Basic Julia-4ti2 interface using system calls. Currently includes the minimize, groebner, normalform, markov and graver 4ti2 commands.\n\n\n\n\n\n","category":"module"},{"location":"FourTi2.html#IPGBs.FourTi2._4ti2_clear-Tuple{String}","page":"FourTi2","title":"IPGBs.FourTi2._4ti2_clear","text":"Internal use.\n\nRemoves the temporary files used to communicate between Julia and 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2._4ti2_read-Tuple{String}","page":"FourTi2","title":"IPGBs.FourTi2._4ti2_read","text":"Internal use.\n\nReads a Julia array from a given file written by 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2._4ti2_write-Union{Tuple{T}, Tuple{Array{T}, String}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2._4ti2_write","text":"Internal use.\n\nWrites a Julia array to a file in a format that can be read by 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.graver","page":"FourTi2","title":"IPGBs.FourTi2.graver","text":"Calls 4ti2's graver command.\n\nTODO: Implement other options (lower and upper bound, arbitrary signs, support to lattice bases instead of matrices...)\n\n\n\n\n\n","category":"function"},{"location":"FourTi2.html#IPGBs.FourTi2.groebner-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.groebner","text":"Interface with the 4ti2 groebner command. Computes the Gröbner Basis of the toric ideal given by A using c as the ordering.\n\nIf lattice is true, A is a lattice basis instead.\n\nReturns the Gröbner Basis as a matrix where each row corresponds to a pure binomial in it.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.groebnernf-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.groebnernf","text":"Calls 4ti2's groebner command followed by normalform. This is equivalent to minimize, except it generates a Gröbner basis in as output and doesn't apply the optimizations of the latter command.\n\nReturns the optimal solution to the given IP along with its objective value.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.markov-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.markov","text":"Returns the minimal Markov basis of A with respect to c as a matrix, where the rows are the elements of the basis.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.minimize-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.minimize","text":"Interface with the 4ti2 minimize command. Solves the Integer Programming problem:\n\nmin c' * x s.t. A * x = b x >= 0\n\nwhere b = A * xinit using Gröbner Basis methods / 4ti2. This is essentially equivalent to calling groebner followed by normalform, but a few optimizations are applied (group relaxations + upper bounds)\n\nI found that –precision=arb is often necessary here to avoid errors.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.normalform-Tuple{Matrix{Int64}, Array{Int64}, Vector{Int64}}","page":"FourTi2","title":"IPGBs.FourTi2.normalform","text":"Interface with the 4ti2 normalform command. Computes the normal form of xinit with respect to the Gröbner Basis of the toric ideal given by A using c as an ordering. This can be called multiple times for various xinit without recomputing the Gröbner Basis.\n\nReturns the normal form and its value using c as objective function.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.write_4ti2_input-Union{Tuple{T}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}, Vector{Bool}}, Tuple{Matrix{Int64}, Array{T}, Vector{Int64}, Vector{Bool}, Any}} where T<:Real","page":"FourTi2","title":"IPGBs.FourTi2.write_4ti2_input","text":"Writes an integer programming problem in 4ti2-readable format.\n\n\n\n\n\n","category":"method"},{"location":"FourTi2.html#IPGBs.FourTi2.write_4ti2_sign","page":"FourTi2","title":"IPGBs.FourTi2.write_4ti2_sign","text":"Writes sign file for 4ti2.\n\n\n\n\n\n","category":"function"},{"location":"Binomials.html#Binomials.jl","page":"Binomials","title":"Binomials.jl","text":"","category":"section"},{"location":"Binomials.html","page":"Binomials","title":"Binomials","text":"Documentation for Binomials.jl","category":"page"},{"location":"Binomials.html","page":"Binomials","title":"Binomials","text":"Modules = [IPGBs.Binomials]","category":"page"},{"location":"Binomials.html#IPGBs.GBElements.minus-Tuple{Vector{Int64}, IPGBs.Binomials.Binomial, IPGBs.Binomials.Binomial}","page":"Binomials","title":"IPGBs.GBElements.minus","text":"Creates g - h in preallocated vector result.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#Markov.jl","page":"Markov","title":"Markov.jl","text":"","category":"section"},{"location":"Markov.html","page":"Markov","title":"Markov","text":"Documentation for Markov.jl","category":"page"},{"location":"Markov.html","page":"Markov","title":"Markov","text":"Modules = [IPGBs.Markov]","category":"page"},{"location":"Markov.html#IPGBs.Markov","page":"Markov","title":"IPGBs.Markov","text":"Implementation of algorithms to compute Markov bases. These are necessary as sets of generators of an ideal for computing Gröbner bases.\n\nTwo methods are implemented:\n\na simplified method that only works when all data defining an IP is negative\nthe project-and-lift algorithm of 4ti2 / Malkin's thesis\n\n\n\n\n\n","category":"module"},{"location":"Markov.html#IPGBs.Markov.ProjectAndLiftState","page":"Markov","title":"IPGBs.Markov.ProjectAndLiftState","text":"State of the project-and-lift algorithm representing the relevant\ninformation during a specific iteration.\n\n- `original_instance`: the original IPInstance being solved\n\n- `working_instance`: instance including potential upper bounds for efficiency\n\n- `unlifted`: the remaining unlifted variables (original indexing, following\n`working_instance`)\n\n- `nonnegative`: the variables that have nonnegative constraints (original indexing)\n\n- `relaxation`: IPInstance representing the problem with the non-negativity of\nthe unlifted variables relaxed\n\n- `markov`: current partial Markov basis (indexed by the permuted variables)\n\n- `primal_solutions`: feasible solutions for the original problem (and thus all of\nits group relaxations). Indexed by the relaxation variables.\n\n- `dual_solution: feasible solution for `relaxation`. Computing a feasible\nsolution is essentially free in project-and-lift, so we always compute one.\nIf it is ever feasible for the original problem, it is also optimal for it.\nUses the variable ordering of `relaxation`.\n\n- `optimal_solution`: The optimal solution for the original problem, if known\n(original indexing)\n\n- `has_optimal_solution`: Whether the optimal solution is known.\n\n- `stats`: Total statistics for this run of project-and-lift\n\n- `completion`: The GB algorithm to be used. :IPGBs and :4ti2 are supported.\n\n\n\n\n\n","category":"type"},{"location":"Markov.html#IPGBs.Markov.can_lift-Tuple{Vector{Vector{Int64}}, Int64}","page":"Markov","title":"IPGBs.Markov.can_lift","text":"can_lift(markov :: Vector{Vector{Int}}, i :: Int)\n\nReturn true if the variable indexed by `i` can be immediately lifted given\nthe current Markov basis `markov`.\n\nThis happens when there is no element in `markov` with a positive coefficient.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.initialize_project_and_lift-Tuple{IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.initialize_project_and_lift","text":"initialize_project_and_lift(instance :: IPInstance)\n\nCreate the initial state of the project-and-lift algorithm for IP instance, including a Markov basis for its group relaxation.\n\nThe group relaxation Markov basis is obtained through the Hermite Normal Form algorithm.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.is_finished-Tuple{IPGBs.Markov.ProjectAndLiftState}","page":"Markov","title":"IPGBs.Markov.is_finished","text":"is_finished(pl_state::ProjectAndLiftState)\n\nCheck whether the project-and-lift algorithm is ready to terminate at pl_state.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.lift_and_relax-Tuple{IPGBs.Markov.ProjectAndLiftState, Vector{Vector{Int64}}}","page":"Markov","title":"IPGBs.Markov.lift_and_relax","text":"lift_and_relax(\npl_state :: ProjectAndLiftState,\nmarkov :: Vector{Vector{Int}}\n\n) :: ProjectAndLiftState\n\nLift the variables in `pl_state` according to `markov` generating a new state\nwith the updated group relaxation, Markov basis and solutions.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.lift_bounded-Tuple{IPGBs.Markov.ProjectAndLiftState, Int64}","page":"Markov","title":"IPGBs.Markov.lift_bounded","text":"lift_bounded(\npl_state :: ProjectAndLiftState,\ni :: Int\n\n) :: Vector{Vector{Int}}\n\nLift the variable indexed by `i` in `pl_state` using a Gröbner basis computation.\nThis generates a Markov basis for the next group relaxation.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.lift_unbounded-Tuple{IPGBs.Markov.ProjectAndLiftState, Int64, Vector{Int64}}","page":"Markov","title":"IPGBs.Markov.lift_unbounded","text":"lift_unbounded(\npl_state :: ProjectAndLiftState,\ni :: Int,\nray :: Vector{Int}\n\n) :: Vector{Vector{Int}}\n\nLift the variable indexed by `i` in `pl_state` using `ray` that proves that\nthe variable is unbounded in `pl_state.relaxation`.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.lift_variables!-Tuple{IPGBs.Markov.ProjectAndLiftState, Vector{Vector{Int64}}}","page":"Markov","title":"IPGBs.Markov.lift_variables!","text":"lift_variables!(\npl_state :: ProjectAndLiftState,\nmarkov :: Vector{Vector{Int}}\n\n)\n\nMark all unlifted variables that can be lifted in `pl_state` as nonnegative\nand lift them.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.markov_basis","page":"Markov","title":"IPGBs.Markov.markov_basis","text":"Compute a Markov basis of an IP.\n\n\n\n\n\n","category":"function"},{"location":"Markov.html#IPGBs.Markov.most_negative-Tuple{Any, Any}","page":"Markov","title":"IPGBs.Markov.most_negative","text":"most_negative(sigma, solution)\n\nFind the index of the most negative variable in `solution` indexed by `sigma`.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.next-Tuple{IPGBs.Markov.ProjectAndLiftState}","page":"Markov","title":"IPGBs.Markov.next","text":"next(\ns::ProjectAndLiftState;\ncompletion :: Symbol = :Buchberger,\ntruncation_type::Symbol = :LP\n\n)::ProjectAndLiftState\n\nRun a single iteration of the project-and-lift algorithm over state, returning the new state after that iteration.\n\nOne iteration involves lifting a previously unlifted variable, either through a linear program or a Gröbner Basis computation.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.optimize_relaxation!-Tuple{IPGBs.Markov.ProjectAndLiftState}","page":"Markov","title":"IPGBs.Markov.optimize_relaxation!","text":"optimize_relaxation!(pl_state :: ProjectAndLiftState)\n\nOptimize `pl_state.dual_solution`, which is feasible for `pl_state.relaxation`,\nobtaining an optimal solution for the relaxation.\n\nGröbner bases are used to optimize the solution.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.original_index-Tuple{Int64, IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.original_index","text":"original_index(i :: Int, r :: IPInstance)\n\nIndex of `r`'s variable `i` in the original instance.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.project_and_lift-Tuple{IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.project_and_lift","text":"project_and_lift(\ninstance::IPInstance;\ncompletion :: Symbol = :IPGBs,\ntruncation_type::Symbol = :LP,\noptimize :: Bool = false,\nfeasible :: Bool = false,\nquiet :: Bool = true,\nsolution :: Vector{Int} = zeros(Int, instance.n)\n\n)::Tuple{Vector{Vector{Int}}, Bool, Vector{Int}, Float64}\n\nCompute a Markov basis of instance using the project-and-lift algorithm.\n\nTruncation is done with respect to truncation_type. If truncation_type is None, then a full Markov basis is computed instead.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.relax_and_reorder-Tuple{IPGBs.Markov.ProjectAndLiftState, Vector{Vector{Int64}}}","page":"Markov","title":"IPGBs.Markov.relax_and_reorder","text":"relax_and_reorder(\npl_state :: ProjectAndLiftState,\nmarkov :: Vector{Vector{Int}}\n\n) :: Tuple{IPInstance, Vector{Vector{Int}}, Vector{Vector{Int}}, Vector{Int}}\n\nRelax the non-negativity constraints of `pl_state.working_instance` according to\n`pl_state.nonnegative`, and reorder the Markov basis and solutions to match the\nnew variable ordering.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.relaxation_feasible-Tuple{IPGBs.Markov.ProjectAndLiftState}","page":"Markov","title":"IPGBs.Markov.relaxation_feasible","text":"relaxation_feasible(pl_state :: ProjectAndLiftState)\n\nThe feasible solution for the relaxation, in the original variable ordering.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.relaxation_index-Tuple{Int64, IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.relaxation_index","text":"relaxation_index(i :: Int, relaxation :: IPInstance)\n\nIndex of original variable `i` in `relaxation`.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.simple_markov-Tuple{IPGBs.IPInstances.IPInstance}","page":"Markov","title":"IPGBs.Markov.simple_markov","text":"simple_markov(instance :: IPInstance) :: Vector{Vector{Int}}\n\nCompute a Markov basis of instance with the simplified algorithm. Assumes all data in instance.A and instance.b is non-negative.\n\nThe simplified algorithm uses the fact (proved in, e.g. Thomas and Weismantel (1997)) that the unit vectors on the original variables of the IP form a Markov basis.\n\n\n\n\n\n","category":"method"},{"location":"Markov.html#IPGBs.Markov.truncate_markov-Tuple{Vector{Vector{Int64}}, IPGBs.IPInstances.IPInstance, Symbol}","page":"Markov","title":"IPGBs.Markov.truncate_markov","text":"truncate_markov(\nmarkov::Vector{Vector{Int}},\ninstance::IPInstance,\ntruncation_type::Symbol\n\n)::Vector{Vector{Int}}\n\nCompute a subset of markov including only vectors which shouldn't be truncated according to the rule given by truncation_type.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#FastBitSets.jl","page":"FastBitSets","title":"FastBitSets.jl","text":"","category":"section"},{"location":"FastBitSets.html","page":"FastBitSets","title":"FastBitSets","text":"Documentation for FastBitSets.jl","category":"page"},{"location":"FastBitSets.html","page":"FastBitSets","title":"FastBitSets","text":"Modules = [IPGBs.FastBitSets]","category":"page"},{"location":"FastBitSets.html#IPGBs.FastBitSets","page":"FastBitSets","title":"IPGBs.FastBitSets","text":"Specialized module for faster bitsets in the context of GBs / IP.\n\n\n\n\n\n","category":"module"},{"location":"FastBitSets.html#IPGBs.FastBitSets.BitTriangle","page":"FastBitSets","title":"IPGBs.FastBitSets.BitTriangle","text":"A BitTriangle stores a bit of data for each pair (i, j) with i != j. Data can be set and accessed for both (i, j) and (j, i), even though it is only stored once per pair.\n\n\n\n\n\n","category":"type"},{"location":"FastBitSets.html#Base.getindex-Tuple{IPGBs.FastBitSets.FastBitSet, Int64}","page":"FastBitSets","title":"Base.getindex","text":"Truth value associated by this bitset to the i-th variable.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#IPGBs.FastBitSets.add_row!-Tuple{IPGBs.FastBitSets.BitTriangle}","page":"FastBitSets","title":"IPGBs.FastBitSets.add_row!","text":"Adds a new row (initialized to false) to this BitTriangle. If this is the n-th row, it will have (n-1) elements.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#IPGBs.FastBitSets.check_indices-Tuple{Any, Any}","page":"FastBitSets","title":"IPGBs.FastBitSets.check_indices","text":"Checks whether the indices i, j can be a pair in a bit triangle. In practice, this means they have to be different.\n\n\n\n\n\n","category":"method"},{"location":"FastBitSets.html#IPGBs.FastBitSets.triangle_indices-Tuple{Any, Any}","page":"FastBitSets","title":"IPGBs.FastBitSets.triangle_indices","text":"Swaps indices so that they are access a valid pair in a bit triangle.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#Orders.jl","page":"Orders","title":"Orders.jl","text":"","category":"section"},{"location":"Orders.html","page":"Orders","title":"Orders","text":"Documentation for Orders.jl","category":"page"},{"location":"Orders.html","page":"Orders","title":"Orders","text":"Modules = [IPGBs.Orders]","category":"page"},{"location":"Orders.html#IPGBs.Orders.GBOrder","page":"Orders","title":"IPGBs.Orders.GBOrder","text":"This is specialized by MonomialOrder in case of Buchberger's algorithm and by ModuleMonomialOrder in case of Signature-based algorithms.\n\n\n\n\n\n","category":"type"},{"location":"Orders.html#IPGBs.Orders.MonomialOrder","page":"Orders","title":"IPGBs.Orders.MonomialOrder","text":"Implements a monomial order from a given cost matrix, including a grevlex tiebreaker if necessary.\n\nThe cost matrix is represented in column-major order to speed up comparisons.\n\n\n\n\n\n","category":"type"},{"location":"Orders.html#IPGBs.Orders.change_ordering!-Tuple{IPGBs.Orders.MonomialOrder, Matrix{Float64}, Matrix{Int64}, Vector{Int64}}","page":"Orders","title":"IPGBs.Orders.change_ordering!","text":"change_ordering!(order :: MonomialOrder, new_order :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int})\n\nChange the order stored in MonomialOrder to a new order.\n\nThe tiebreaker is rebuilt if necessary.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.invert_maximization-Tuple{IPGBs.Orders.MonomialOrder, Bool}","page":"Orders","title":"IPGBs.Orders.invert_maximization","text":"invert_maximization(order :: MonomialOrder, result :: Bool)\n\nInvert result when order is a maximization order.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.is_inverted-Union{Tuple{T}, Tuple{IPGBs.Orders.MonomialOrder, T, AbstractVector{Int64}}} where T<:AbstractVector{Int64}","page":"Orders","title":"IPGBs.Orders.is_inverted","text":"is_inverted(\norder :: MonomialOrder,\nv :: T,\ncosts :: Vector{Int}\n\n) :: Bool where {T <: AbstractVector{Int}}\n\nEfficiently return whether v's leading and trailing terms are inverted.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.is_inverted_generic-Union{Tuple{T}, Tuple{IPGBs.Orders.MonomialOrder, T}} where T<:AbstractVector{Int64}","page":"Orders","title":"IPGBs.Orders.is_inverted_generic","text":"is_inverted_generic(order :: MonomialOrder, v :: T) :: Bool where {T <: AbstractVector{Int}}\n\nReturn true iff the trailing and leading terms of v are inverted with respect to order.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.is_inverted_invlex-Union{Tuple{T}, Tuple{IPGBs.Orders.MonomialOrder, T}} where T<:AbstractVector{Int64}","page":"Orders","title":"IPGBs.Orders.is_inverted_invlex","text":"is_inverted_invlex(order :: MonomialOrder, v :: T) :: Bool where {T <: AbstractVector{Int}}\n\nReturn true iff the trailing and leading terms of v are inverted with respect to the invlex order.\n\nv is inverted according to invlex iff its first non-zero entry is positive. Inversion testing is thus done more efficiently in the invlex case.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.lex_order-Tuple{Int64}","page":"Orders","title":"IPGBs.Orders.lex_order","text":"lex_order(n :: Int) :: MonomialOrder\n\nReturn the lex monomial order with x1 > x2 > ... > xn.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.normalize_order-Tuple{Matrix{Float64}, Matrix{Int64}, Vector{Int64}, Int64, Vector{Bool}}","page":"Orders","title":"IPGBs.Orders.normalize_order","text":"normalize_order(\nC::Matrix{Float64},\nA::Matrix{Int},\nb::Vector{Int},\nnum_vars::Int,\nunbounded::Vector{Bool}\n\n)::Tuple{Matrix{Float64}, Int}\n\nReturn a cost matrix in column-major form giving the same monomial order as C using only the first num_vars variables.\n\nNormalization uses the dual data of the LP min C*x s.t. Ax = b, x >= 0.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.order_costs-Tuple{IPGBs.Orders.MonomialOrder, AbstractVector{Int64}}","page":"Orders","title":"IPGBs.Orders.order_costs","text":"order_costs(\norder :: MonomialOrder,\nv :: AbstractVector{Int}\n\n) :: Vector{Int}\n\nThe cost of some vector according to the cost matrix of order.\n\nThis is the vector weighted by the first column of the cost matrix.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.positive_first_row!-Tuple{Matrix{Float64}, Matrix{Int64}, Vector{Int64}}","page":"Orders","title":"IPGBs.Orders.positive_first_row!","text":"positive_first_row!(C :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int})\n\nModify C so that its first row is strictly positive using dual data from the LP min C*x s.t. Ax = b, x >= 0.\n\nAssumes the given LP is bounded and feasible.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.projection_order-Tuple{Matrix{Float64}, Matrix{Int64}, Vector{Int64}, Int64}","page":"Orders","title":"IPGBs.Orders.projection_order","text":"projection_order(C :: Matrix{Float64}, A :: Matrix{Int}, b :: Vector{Int}, num_vars :: Int)\n\nReturn a matrix corresponding to the same monomial order as C but using only the first num_vars variables.\n\nUses the dual of the LP min C*x s.t. Ax = b, x >= 0 to find such an order.\n\n\n\n\n\n","category":"method"},{"location":"Orders.html#IPGBs.Orders.tiebreak-Tuple{Matrix{Float64}}","page":"Orders","title":"IPGBs.Orders.tiebreak","text":"tiebreak(C :: Matrix{Float64}) :: Matrix{Float64}\n\nReturn a matrix corresponding to the same monomial order as C, tiebreaking it using the revlex order if C does not already specify a full monomial order itself.\n\n\n\n\n\n","category":"method"},{"location":"ZDDs.html#ZDDs.jl","page":"ZDDs.jl","title":"ZDDs.jl","text":"","category":"section"},{"location":"ZDDs.html","page":"ZDDs.jl","title":"ZDDs.jl","text":"Documentation for ZDDs.jl","category":"page"},{"location":"ZDDs.html","page":"ZDDs.jl","title":"ZDDs.jl","text":"Modules = [IPGBs.ZDDs]","category":"page"},{"location":"ZDDs.html#IPGBs.ZDDs","page":"ZDDs.jl","title":"IPGBs.ZDDs","text":"Incomplete implementation of a Zero-suppressed decision diagram (ZDD).\n\nIn theory, ZDDs could be an efficient way to implement the reducer search, but implementing this data structure well is a bit tricky. I intend to complete this implementation later.\n\n\n\n\n\n","category":"module"},{"location":"StandardDecomposition.html#StandardDecomposition.jl","page":"StandardDecomposition","title":"StandardDecomposition.jl","text":"","category":"section"},{"location":"StandardDecomposition.html","page":"StandardDecomposition","title":"StandardDecomposition","text":"Documentation for StandardDecomposition.jl","category":"page"},{"location":"StandardDecomposition.html","page":"StandardDecomposition","title":"StandardDecomposition","text":"Modules = [IPGBs.StandardDecomposition]","category":"page"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.AdmissiblePair","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.AdmissiblePair","text":"Represents an admissible pair, i.e., (x^m, σ) where x^m is a standard monomial and σ is a set of indices disjoint from the support of m.\n\nAdditionally, for this pair to be standard, it has to be minimal w.r.t. the following order: (x^m, σ) <= (x^m', σ') iff x^m divides x^m' and supp(x^m' / x^m) ∪ σ' ⊆ σ.\n\nThe minimal elements w.r.t. this order are the standard pairs and they cover other admissible pairs.\n\n\n\n\n\n","category":"type"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.choose_generator-Tuple{Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.choose_generator","text":"Chooses some generator of the monomial ideal M. For now, it simply picks the first one.\n\nTODO If I ever care about the performance of the standard decomposition, I can try to study whether it matters which generator is picked or not.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.choose_variable-Tuple{Vector{Int64}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.choose_variable","text":"Chooses some variable in the support of monomial. For now, it simply picks the first one.\n\nTODO The same comments from choose_generator apply here.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.ideal_quotient-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Int64}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.ideal_quotient","text":"Quotient of (M : (gen / x^i)). The generators of the quotient are the generators m of M divided by gcd(m, gen / x^i)\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.is_reducible-Tuple{Int64, Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.is_reducible","text":"True iff some generator in gens reduces the i-th element of gens.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.is_standard-Tuple{IPGBs.StandardDecomposition.AdmissiblePair, Vector{IPGBs.StandardDecomposition.AdmissiblePair}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.is_standard","text":"pair is_standard when it is not dominated by any already known standard pairs.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.less_than-Tuple{IPGBs.StandardDecomposition.AdmissiblePair, IPGBs.StandardDecomposition.AdmissiblePair}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.less_than","text":"Implements the following order: (x^m, σ) <= (x^m', σ') iff x^m divides x^m' and supp(x^m' / x^m) ∪ σ' ⊆ σ.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.minimal_generators-Tuple{Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.minimal_generators","text":"Reduces a set of generators gens to a set of minimal generators of the same monomial ideal.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.standard_decomposition-Tuple{Vector{Vector{Int64}}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.standard_decomposition","text":"Implementation of the standard decomposition algorithm introduced in Hosten and Thomas (1998).\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.support_in-Tuple{Vector{Int64}, Vector{Bool}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.support_in","text":"Returns true iff the support of monomial is contained in the set represented by sigma.\n\n\n\n\n\n","category":"method"},{"location":"StandardDecomposition.html#IPGBs.StandardDecomposition.update_ideal!-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"StandardDecomposition","title":"IPGBs.StandardDecomposition.update_ideal!","text":"Updates the set of minimal generators of the ideal generated by gens upon adding new_gen.\n\n\n\n\n\n","category":"method"},{"location":"Optimize.html#Optimize.jl","page":"Optimize","title":"Optimize.jl","text":"","category":"section"},{"location":"Optimize.html","page":"Optimize","title":"Optimize","text":"Documentation for Optimize.jl","category":"page"},{"location":"Optimize.html","page":"Optimize","title":"Optimize","text":"Modules = [IPGBs.Optimize]","category":"page"},{"location":"Optimize.html#IPGBs.Optimize.optimize_with!-Tuple{Vector{Int64}, IPGBs.IPInstances.IPInstance, Vector{Vector{Int64}}}","page":"Optimize","title":"IPGBs.Optimize.optimize_with!","text":"optimize_with(\nsolution :: Vector{Int},\ninstance :: IPInstance,\ntest_set :: Vector{Vector{Int}}\n\n) :: Vector{Int}\n\nUse `test_set` to optimize `solution`, a feasible solution to `instance`,\nreturning a new feasible solution that cannot be further improved by\n`test_set`.\n\nIf `test_set` is a Gröbner basis, then the returned solution is optimal.\nOtherwise, it is simply a locally optimal solution with respect to `test_set`.\n\n\n\n\n\n","category":"method"},{"location":"CombinatorialOptimizationInstances.html#CombinatorialOptimizationInstances.jl","page":"CombinatorialOptimizationInstances.jl","title":"CombinatorialOptimizationInstances.jl","text":"","category":"section"},{"location":"CombinatorialOptimizationInstances.html","page":"CombinatorialOptimizationInstances.jl","title":"CombinatorialOptimizationInstances.jl","text":"Documentation for CombinatorialOptimizationInstances.jl","category":"page"},{"location":"CombinatorialOptimizationInstances.html","page":"CombinatorialOptimizationInstances.jl","title":"CombinatorialOptimizationInstances.jl","text":"Modules = [IPGBs.CombinatorialOptimizationInstances]","category":"page"},{"location":"Walkback.html#Walkback.jl","page":"Walkback","title":"Walkback.jl","text":"","category":"section"},{"location":"Walkback.html","page":"Walkback","title":"Walkback","text":"Documentation for Walkback.jl","category":"page"},{"location":"Walkback.html","page":"Walkback","title":"Walkback","text":"Modules = [IPGBs.Walkback]","category":"page"},{"location":"GBAlgorithms.html#GBAlgorithms.jl","page":"GBAlgorithms","title":"GBAlgorithms.jl","text":"","category":"section"},{"location":"GBAlgorithms.html","page":"GBAlgorithms","title":"GBAlgorithms","text":"Documentation for GBAlgorithms.jl","category":"page"},{"location":"GBAlgorithms.html","page":"GBAlgorithms","title":"GBAlgorithms","text":"Modules = [IPGBs.GBAlgorithms]","category":"page"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.GBAlgorithm","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.GBAlgorithm","text":"A generic Gröbner Basis algorithm. Currently, it can be either a BuchbergerAlgorithm or a SignatureAlgorithm.\n\n\n\n\n\n","category":"type"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.general_truncate-Tuple{IPGBs.GBAlgorithms.GBAlgorithm, IPGBs.GBElements.GBElement}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.general_truncate","text":"general_truncate(algorithm :: GBAlgorithm, binomial :: GBElement) :: Bool\n\nReturn true iff binomial is truncated by the weight criterion or by the general truncation method used by algorithm.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.increment-Tuple{IPGBs.GBAlgorithms.GBAlgorithm, Symbol}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.increment","text":"increment(algorithm :: GBAlgorithm, stat :: Symbol)\n\nIncrement the field stat of stats(algorithm)\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.is_minimization-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.is_minimization","text":"is_minimization(algorithm :: GBAlgorithm) :: Bool\n\nReturn true iff this algorithm is working with problems in minimization form.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.late_pair_elimination-Tuple{IPGBs.GBAlgorithms.GBAlgorithm, IPGBs.GBElements.CriticalPair}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.late_pair_elimination","text":"late_pair_elimination(:: GBAlgorithm, :: CriticalPair)\n\nReturn true iff the given CriticalPair should be eliminated according to this algorithm's criteria.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.prepare_gb_output-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.prepare_gb_output","text":"prepare_gb_output(algorithm :: GBAlgorithm) :: Vector{Vector{Int}}\n\nReturn the user-friendly output Gröbner Basis of algorithm, reduced, sorted and in the original variable ordering.\n\nThis output is compatible with 4ti2's output format.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.reintroduce_truncated!-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.reintroduce_truncated!","text":"reintroduce_truncated!(algorithm :: GBAlgorithm)\n\nAdd truncated elements of the given Markov basis back into the GB.\n\nThis is used at the end of the computation to keep the GB as a basis of the input ideal, regardless of truncation.\n\n\n\n\n\n","category":"method"},{"location":"GBAlgorithms.html#IPGBs.GBAlgorithms.run-Tuple{IPGBs.GBAlgorithms.GBAlgorithm}","page":"GBAlgorithms","title":"IPGBs.GBAlgorithms.run","text":"run(algorithm :: GBAlgorithm, quiet :: Bool) :: Vector{Vector{Int}}\n\nReturn the Gröbner Basis obtained by running algorithm.\n\n\n\n\n\n","category":"method"},{"location":"SingleObjective.html#SingleObjective.jl","page":"SingleObjective","title":"SingleObjective.jl","text":"","category":"section"},{"location":"SingleObjective.html","page":"SingleObjective","title":"SingleObjective","text":"Documentation for SingleObjective.jl","category":"page"},{"location":"SingleObjective.html","page":"SingleObjective","title":"SingleObjective","text":"Modules = [IPGBs.SingleObjective]","category":"page"},{"location":"SingleObjective.html#IPGBs.SingleObjective","page":"SingleObjective","title":"IPGBs.SingleObjective","text":"Tools for solving single objective integer programs given by their model min c' * x s.t. A * x = b x >= 0\n\n\n\n\n\n","category":"module"},{"location":"SingleObjective.html#IPGBs.SingleObjective.lexmin-Tuple{Matrix{Int64}, Vector{Int64}, Matrix{Int64}, Int64}","page":"SingleObjective","title":"IPGBs.SingleObjective.lexmin","text":"lexmin(\nA :: Matrix{Int},\nb :: Vector{Int},\nC :: Matrix{Int},\ni :: Int;\nsolver :: String = \"Cbc\"\n\n) :: Tuple{Vector{Int}, Int}\n\nSolve the lexicographical minimization of the multiobjective problem\n\nmin. C * x s.t. A * x == b x >= 0, x integer\n\nconsidering the i-th objective as the first objective, and optimizing the remaining objectives as tiebreakers in order 1, 2, ..., i - 1, i + 1, ... p.\n\n\n\n\n\n","category":"method"},{"location":"SingleObjective.html#IPGBs.SingleObjective.linear_relaxation-Tuple{Matrix{Int64}, Vector{Int64}, Vector{Int64}}","page":"SingleObjective","title":"IPGBs.SingleObjective.linear_relaxation","text":"Solves the linear relaxation of the integer program min c' * x s.t. A * x = b x >= 0 using JuMP.\n\n\n\n\n\n","category":"method"},{"location":"SingleObjective.html#IPGBs.SingleObjective.makemodel-Tuple{Matrix{Int64}, Vector{Int64}, Vector{Int64}}","page":"SingleObjective","title":"IPGBs.SingleObjective.makemodel","text":"Creates a JuMP model (for the given solver) from A, b and c.\n\n\n\n\n\n","category":"method"},{"location":"SingleObjective.html#IPGBs.SingleObjective.usesolver-Tuple{Matrix{Int64}, Vector{Int64}, Vector{Int64}}","page":"SingleObjective","title":"IPGBs.SingleObjective.usesolver","text":"Uses JuMP / Cbc to solve an integer programming problem given in the form min c' * x s.t. A * x = b x >= 0\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveTools.html#MultiObjectiveTools.jl","page":"MultiObjectiveTools","title":"MultiObjectiveTools.jl","text":"","category":"section"},{"location":"MultiObjectiveTools.html","page":"MultiObjectiveTools","title":"MultiObjectiveTools","text":"Documentation for MultiObjectiveTools.jl","category":"page"},{"location":"MultiObjectiveTools.html","page":"MultiObjectiveTools","title":"MultiObjectiveTools","text":"Modules = [IPGBs.MultiObjectiveTools]","category":"page"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools","text":"Some useful functions to deal with multi-objective optimization problems.\n\n\n\n\n\n","category":"module"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools.change_direction!-Tuple{Union{Set{Vector{Int64}}, Vector{Vector{Int64}}}}","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools.change_direction!","text":"Changes direction of the given Pareto set by changing signs (i.e., transform a solution from a minimization problem into maximization and vice-versa).\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools.contained_by-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools.contained_by","text":"Checks whether pareto1 is contained by pareto2.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools.is_feasible-Tuple{Vector{Int64}, Matrix{Int64}, Vector{Int64}}","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools.is_feasible","text":"is_feasible(x :: Vector{Int}, A :: Matrix{Int}, b :: Vector{Int})\n\nCheck whether `x` is feasible for `Ax = b, x \\geq 0`.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools.is_nondominated-Tuple{Int64, Vector{Vector{Int64}}}","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools.is_nondominated","text":"Checks whether the solution at index i of pareto is nondominated with respect to the rest of pareto.\n\nReturns nothing in case the solution is nondominated, or an index pointing to proof that the solution is inefficient, otherwise.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools.pareto_vector-Tuple{Set{Vector{Int64}}}","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools.pareto_vector","text":"Creates a vector of pareto points from a set of pareto points\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveTools.html#IPGBs.MultiObjectiveTools.print_dominated-Tuple{Vector{Vector{Int64}}}","page":"MultiObjectiveTools","title":"IPGBs.MultiObjectiveTools.print_dominated","text":"For debugging. Prints all dominated points in pareto.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPInstances.jl","page":"IPInstances","title":"IPInstances.jl","text":"","category":"section"},{"location":"IPInstances.html","page":"IPInstances","title":"IPInstances","text":"Documentation for IPInstances.jl","category":"page"},{"location":"IPInstances.html","page":"IPInstances","title":"IPInstances","text":"Modules = [IPGBs.IPInstances]","category":"page"},{"location":"IPInstances.html#IPGBs.IPInstances.IPInstance","page":"IPInstances","title":"IPGBs.IPInstances.IPInstance","text":"Represents an instance of a problem\n\nmin C * x\n\ns.t. A * x = b\n\n0 <= x <= u\n\nx in ZZ^n\n\nThe instance is stored in normalized form, with permuted variables so that the variables appear in the following order: bounded, non-negative but unbounded, unrestricted.\n\n\n\n\n\n","category":"type"},{"location":"IPInstances.html#IPGBs.IPInstances.apply_permutation-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"IPInstances","title":"IPGBs.IPInstances.apply_permutation","text":"apply_permutation(vector_set :: Vector{Vector{Int}}, permutation :: Vector{Int}) :: Vector{Vector{Int}}\n\nApply permutation to each vector in vector_set.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.compute_permutation-Tuple{Vector{Bool}, Vector{Bool}}","page":"IPInstances","title":"IPGBs.IPInstances.compute_permutation","text":"compute_permutation(bounded :: Vector{Bool}, nonnegative :: Vector{Bool}) :: Tuple{Vector{Int}, Int, Int}\n\nReturn a permutation of variables that puts the variables in the order [ bounded ; unbounded and restricted ; unrestricted ], along with the indices of the last bounded variable and the last unbounded but restricted variable.\n\nThis operation should be stable with respect to the initial ordering of variables.\n\nA permutation is represented by a vector perm such that perm[i] = j means that variable i is sent to j by the permutation.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.extract_bound-Tuple{JuMP.Model, JuMP.ConstraintRef, Vector{JuMP.VariableRef}}","page":"IPInstances","title":"IPGBs.IPInstances.extract_bound","text":"extract_bound(model :: JuMP.Model, c :: JuMP.ConstraintRef, x :: Vector{JuMP.VariableRef})\n\nExtract lower / upper bound value from a VariableRef type constraint c.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.extract_constraint-Tuple{JuMP.Model, JuMP.ConstraintRef, Vector{JuMP.VariableRef}}","page":"IPInstances","title":"IPGBs.IPInstances.extract_constraint","text":"extract_constraint(model :: JuMP.Model, c :: JuMP.ConstraintRef, x :: Vector{JuMP.VariableRef})\n\nExtract numerical coefficients from a JuMP constraint, returning a vector with left-hand side coefficients and the right-hand side value.\n\nAssumes this is a scalar constraint (= a single constraint).\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.group_relaxation-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.group_relaxation","text":"group_relaxation(instance :: IPInstance) :: IPInstance\n\nReturn a new IPInstance corresponding to the relaxation in instance of the non-negativity constraints of the basic variables in the optimal solution of its linear relaxation.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.is_bounded-Tuple{Int64, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.is_bounded","text":"is_bounded(i :: Int, instance :: IPInstance) :: Bool\n\nReturn true iff the variable of index i in instance is bounded.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.is_nonnegative-Tuple{Int64, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.is_nonnegative","text":"is_nonnegative(i :: Int, instance :: IPInstance) :: Bool\n\nReturn true iff the variable of index i in instance is nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.jump_model-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.jump_model","text":"initial_jump_model(\ninstance :: IPInstance,\nfirst_objective :: Int = 1\n\n)\n\nReturn a JuMP Model corresponding to the IPInstance.\n\nThe JuMP Model keeps all objectives in its objective function matrix.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.nonnegative_data_only-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.nonnegative_data_only","text":"nonnegative_data_only(instance :: IPInstance) :: Bool\n\nReturn true iff all data in instance.A and instance.b is non-negative and all variables are non-negative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.nonnegative_vars-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.nonnegative_vars","text":"nonnegative_vars(instance :: IPInstance) :: Vector{Bool}\n\nReturn a boolean vector indicating whether each variable of instance is non-negative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.nonnegativity_relaxation-Tuple{IPGBs.IPInstances.IPInstance, Vector{Bool}}","page":"IPInstances","title":"IPGBs.IPInstances.nonnegativity_relaxation","text":"nonnegativity_relaxation(instance :: IPInstance, nonnegative :: Vector{Bool}) :: IPInstance\n\nReturn a new IPInstance corresponding to the relaxation of instance consisting of only keeping the non-negativity constraints of variables marked in nonnegative.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.normalize_ip-Union{Tuple{T}, Tuple{Matrix{Int64}, Vector{Int64}, Matrix{T}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}}} where T<:Real","page":"IPInstances","title":"IPGBs.IPInstances.normalize_ip","text":"normalize_ip(A :: Matrix{Int}, b :: Vector{Int}, c :: Matrix{T}, u :: Vector{<: Union{Int, Nothing}}, nonnegative :: Vector{Bool}; ...) where {T <: Real}\n\nTransform a problem in the form: max C * x s.t. Ax <= b 0 <= x <= u\n\nto something of the form max C * x s.t. Ax == b x == u\n\nby adding slack variables.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.original_variable_order-Tuple{Vector{Vector{Int64}}, IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.original_variable_order","text":"original_variable_order(vector_set :: Vector{Vector{Int}}, instance :: IPInstance) :: Vector{Vector{Int}}\n\nInvert the variable permutation of instance over vector_set, returning to the original problem's variable order.\n\nThis is useful to give users output in the same variable order they input.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.random_ipinstance-Tuple{Int64, Int64}","page":"IPInstances","title":"IPGBs.IPInstances.random_ipinstance","text":"random_instance(m :: Int, n :: Int) :: IPInstance\n\nReturn a random feasible IPInstance with m constraints and n variables.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.solve-Tuple{IPGBs.IPInstances.IPInstance}","page":"IPInstances","title":"IPGBs.IPInstances.solve","text":"solve(instance :: IPInstance)\n\nReturn the optimal solution to this IPInstance. This solution is computed\nusing a traditional IP solver.\n\n\n\n\n\n","category":"method"},{"location":"IPInstances.html#IPGBs.IPInstances.unboundedness_proof-Tuple{IPGBs.IPInstances.IPInstance, Int64}","page":"IPInstances","title":"IPGBs.IPInstances.unboundedness_proof","text":"unboundedness_proof(\ninstance :: IPInstance,\ni :: Int\n\n) :: Vector{Int}\n\nReturn a vector u in kernel(instance.A) proving that the variable of index i is unbounded.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveStats.html#MultiObjectiveStats.jl","page":"MultiObjectiveStats","title":"MultiObjectiveStats.jl","text":"","category":"section"},{"location":"MultiObjectiveStats.html","page":"MultiObjectiveStats","title":"MultiObjectiveStats","text":"Documentation for MultiObjectiveStats.jl","category":"page"},{"location":"MultiObjectiveStats.html","page":"MultiObjectiveStats","title":"MultiObjectiveStats","text":"Modules = [IPGBs.MultiObjectiveStats]","category":"page"},{"location":"MultiObjectiveStats.html#IPGBs.MultiObjectiveStats.Stats","page":"MultiObjectiveStats","title":"IPGBs.MultiObjectiveStats.Stats","text":"Struct storing the data of a MultiObjectiveAlgorithms.moipgbsolve run to analyze and include as a table in papers.\n\n\n\n\n\n","category":"type"},{"location":"MultiObjectiveStats.html#Base.show-Tuple{IO, IPGBs.MultiObjectiveStats.Stats}","page":"MultiObjectiveStats","title":"Base.show","text":"Shows a MultiObjecitveStats struct with all data in the same row to easily make tables for papers.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#SignaturePolynomials.jl","page":"SignaturePolynomials","title":"SignaturePolynomials.jl","text":"","category":"section"},{"location":"SignaturePolynomials.html","page":"SignaturePolynomials","title":"SignaturePolynomials","text":"Documentation for SignaturePolynomials.jl","category":"page"},{"location":"SignaturePolynomials.html","page":"SignaturePolynomials","title":"SignaturePolynomials","text":"Modules = [IPGBs.SignaturePolynomials]","category":"page"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials","text":"Implementation of the basic signature-polynomial pairs structures.\n\nTODO this whole module would probably be cleaner if it was separated in multiple modules. One defining signatures, another defining module monomial orders, another defining SigPolys and so on.\n\n\n\n\n\n","category":"module"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ModuleMonomialOrder","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ModuleMonomialOrder","text":"An enum containing all types of module monomial orders available for this signature algorithm implementation.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ModuleMonomialOrdering","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ModuleMonomialOrdering","text":"Represents a module monomial ordering. This has to store a reference to the current basis in order to implement an order like lt-pot (Schreyer's order).\n\nThis is mutable because, for convenience, it may sometimes be necessary to change monomial_order.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.SigPoly","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.SigPoly","text":"Represents a polynomial with its signature. Used in signature-based algorithms. Stores its sig-lead ratio to compare signatures more efficiently when building S-pairs, Koszul syzygies, reductions and elimination criteria.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.Signature","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.Signature","text":"A signature, or module monomial, is represented by a monomial with an index, where the monomial is the coefficient of the module basis vector of the given index.\n\nTODO I'm thinking that monomial could easily be a sparse vector in cases with many variables. I expect many entries to be 0 in this case, but it is worth it to experiment with that.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.SignaturePair","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.SignaturePair","text":"An S-pair represented sparsely, before building it from binomials explicitly. Includes a signature to allow the signature-based algorithm to proceed by increasing signature of S-pairs.\n\n\n\n\n\n","category":"type"},{"location":"SignaturePolynomials.html#Base.Order.lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"Base.Order.lt","text":"Compares two SigPolys as polynomials wrt to the monomial order of o. Ignores signatures and sig-leads.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#Base.Order.lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}, IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"Base.Order.lt","text":"Compares two signatures with respect to the given ModuleMonomialOrdering. Returns true iff s1 is strictly smaller than s2 with respect to o.\n\nTODO I wonder if I shouldn't also store the weighted versions of signature.monomial This could make all orders more efficient, the obvious tradeoff being memory.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.build-Union{Tuple{T}, Tuple{Vector{Int64}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.build","text":"Builds u - v with signature given by pair.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.degree_reducible-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.degree_reducible","text":"Checks a reduction condition for implicit variables in the case T == GradedBinomial. Currently unused, because GradedBinomials are not supported with signatures.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.reduce!-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.Orders.GBOrder}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.reduce!","text":"Computes g -= h in-place, assumes this is a regular reduction, so that sig(g - h) = sig(g).\n\nReturns true iff g reduced to zero.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.signature_reducible-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.Signature, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.signature_reducible","text":"Checks whether g is signature reducible by a reducer with reducer_sig. This means the reducer (after multiplying by a lt quotient) has lower signature than g wrt the module monomial ordering.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.GBElements.singular_top_reducible-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.Signature}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.GBElements.singular_top_reducible","text":"Checks whether g is singular top-reducible by some reducer with signature reducer_sig. Assumes this reducer divides g.\n\nTODO singulartopreducible and signaturereducible both compare the same signatures. I could call the same function signaturecompare in both! In fact, given the situation I use this, I should just call signature_compare there and be done with it!\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.divides-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.divides","text":"Returns true iff s1 divides s2.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.image_leading_term-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, Array{IPGBs.SignaturePolynomials.SigPoly{T}, 1}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.image_leading_term","text":"Returns the leading term image of s by the function mapping the module basis element of index i to the i-th element of generators.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.koszul-Union{Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.koszul","text":"Returns the Koszul signature of the pair of gb indexed by (i, j), if it is regular. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ltpot_compare-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder, Array{IPGBs.SignaturePolynomials.SigPoly{T}, 1}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ltpot_compare","text":"Compares s1 and s2 in Schreyer's order (aka ltpot). This means first comparing the leading terms of the images of the signatures in the polynomial ring and then breaking ties by the pot order.\n\nReturns :lt, :eq or :gt if s1 is smaller, equal or greater than s2 respectively.\n\nTODO try to implement this more efficiently. The way I'm doing this here is very slow, due to all the calls to imageleadingterm...\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.ltpot_lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder, Array{IPGBs.SignaturePolynomials.SigPoly{T}, 1}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.ltpot_lt","text":"Returns true iff s1 < s2 in the ltpot (Schreyer) order.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.pot_compare-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.pot_compare","text":"Compares s1 and s2 in the position-over-term (pot) order, that is, compare signatures first by module index and break ties by the given monomial order on the coefficients.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.pot_lt-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.pot_lt","text":"Returns true iff s1 < s2 in the top order.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.regular_spair-Union{Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.regular_spair","text":"Creates an SPair S(i, j) if it is regular, otherwise returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.siglead-Union{Tuple{T}, Tuple{T, IPGBs.SignaturePolynomials.Signature}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.siglead","text":"Computes the SigLead ratio of binomial with signature. This is defined as a signature with the same index as signature, but with monomial defined by signature.monomial - leading_term(binomial)\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.signature_compare-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.signature_compare","text":"Returns :lt, :eq or :gt when sig1 is respectively smaller, equal or greater than sig2 with respect to module_order.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.signature_lt-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.signature_lt","text":"Returns sig1 < sig2 according to the given module_order\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.spair_signature-Union{Tuple{T}, Tuple{Int64, Int64, IPGBs.BinomialSets.BinomialSet{IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}}} where T<:IPGBs.GBElements.GBElement","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.spair_signature","text":"Computes the signature of the i-branch of the S-pair (i, j). Just call with i and j inverted to compute the same thing for j.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.top_compare-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.top_compare","text":"Compares s1 and s2 in the term-over-position (top) order, that is, compare signature first by monomial order on the coefficients breaking ties by the module index.\n\nReturns :lt, :eq or :gt if s1 is smaller, equal or greater than s2 respectively.\n\n\n\n\n\n","category":"method"},{"location":"SignaturePolynomials.html#IPGBs.SignaturePolynomials.top_lt-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.Signature, IPGBs.Orders.MonomialOrder}","page":"SignaturePolynomials","title":"IPGBs.SignaturePolynomials.top_lt","text":"Returns true iff s1 < s2 in the top order.\n\n\n\n\n\n","category":"method"},{"location":"SupportMatrixTrees.html#SupportMatrixTrees.jl","page":"SupportMatrixTrees","title":"SupportMatrixTrees.jl","text":"","category":"section"},{"location":"SupportMatrixTrees.html","page":"SupportMatrixTrees","title":"SupportMatrixTrees","text":"Documentation for SupportMatrixTrees.jl","category":"page"},{"location":"SupportMatrixTrees.html","page":"SupportMatrixTrees","title":"SupportMatrixTrees","text":"Modules = [IPGBs.SupportMatrixTrees]","category":"page"},{"location":"LatticePrograms.html#LatticePrograms.jl","page":"LatticePrograms.jl","title":"LatticePrograms.jl","text":"","category":"section"},{"location":"LatticePrograms.html","page":"LatticePrograms.jl","title":"LatticePrograms.jl","text":"Documentation for LatticePrograms.jl","category":"page"},{"location":"LatticePrograms.html","page":"LatticePrograms.jl","title":"LatticePrograms.jl","text":"Modules = [IPGBs.LatticePrograms]","category":"page"},{"location":"LatticePrograms.html#IPGBs.LatticePrograms.LatticeProgram","page":"LatticePrograms.jl","title":"IPGBs.LatticePrograms.LatticeProgram","text":"Lattice program in the form:\n\nmin {c^T x : x - u in L}\n\nwhere\n    c : objective\n    u : fiber_solution\n    L : the lattice generated by the columns of basis\n\n\n\n\n\n","category":"type"},{"location":"Buchberger.html#Buchberger.jl","page":"Buchberger","title":"Buchberger.jl","text":"","category":"section"},{"location":"Buchberger.html","page":"Buchberger","title":"Buchberger","text":"Documentation for Buchberger.jl","category":"page"},{"location":"Buchberger.html","page":"Buchberger","title":"Buchberger","text":"Modules = [IPGBs.Buchberger]","category":"page"},{"location":"Buchberger.html#IPGBs.Buchberger","page":"Buchberger","title":"IPGBs.Buchberger","text":"Implements a combinatorial Buchberger algorithm for Integer Programming where all data is non-negative. Based on Thomas and Weismantel (1997).\n\n\n\n\n\n","category":"module"},{"location":"Buchberger.html#IPGBs.Buchberger.BuchbergerState","page":"Buchberger","title":"IPGBs.Buchberger.BuchbergerState","text":"The state of Buchberger S-binomial generation.\n\n\n\n\n\n","category":"type"},{"location":"Buchberger.html#IPGBs.Buchberger.next_state!-Tuple{IPGBs.Buchberger.BuchbergerState}","page":"Buchberger","title":"IPGBs.Buchberger.next_state!","text":"Updates the state to the indices of the next generated S-pair. Returns the indices of the new state, if it corresponds to a new S-pair, or nothing, if all S-pairs were already generated.\n\n\n\n\n\n","category":"method"},{"location":"Buchberger.html#IPGBs.GBAlgorithms.late_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.Buchberger.BuchbergerAlgorithm{T}, IPGBs.GBElements.CriticalPair}} where T<:IPGBs.GBElements.GBElement","page":"Buchberger","title":"IPGBs.GBAlgorithms.late_pair_elimination","text":"Applies the GCD criterion to determine whether or not to eliminate the given S-pair.\n\n\n\n\n\n","category":"method"},{"location":"Buchberger.html#IPGBs.GBAlgorithms.next_pair!-Union{Tuple{IPGBs.Buchberger.BuchbergerAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"Buchberger","title":"IPGBs.GBAlgorithms.next_pair!","text":"Produces the next BinomialPair to be processed by the Buchberger algorithm, if one exists, or nothing otherwise.\n\nAuto-reduces the partial GB periodically (for consistency with 4ti2).\n\n\n\n\n\n","category":"method"},{"location":"Buchberger.html#IPGBs.GBAlgorithms.quick_truncation-Union{Tuple{T}, Tuple{IPGBs.Buchberger.BuchbergerAlgorithm{T}, T}} where T<:IPGBs.GBElements.GBElement","page":"Buchberger","title":"IPGBs.GBAlgorithms.quick_truncation","text":"GBAlgorithms.quick_truncation(\nalgorithm :: BuchbergerAlgorithm{T},\ng :: T\n\n) where {T <: GBElement}\n\nReturn true iff g is truncated by the weight criterion, that is, its weight is higher than the maximum weight for fibers of the given instance.\n\n\n\n\n\n","category":"method"},{"location":"Statistics.html#Statistics.jl","page":"Statistics","title":"Statistics.jl","text":"","category":"section"},{"location":"Statistics.html","page":"Statistics","title":"Statistics","text":"Documentation for Statistics.jl","category":"page"},{"location":"Statistics.html","page":"Statistics","title":"Statistics","text":"Modules = [IPGBs.Statistics]","category":"page"},{"location":"SolverTools.html#SolverTools.jl","page":"SolverTools","title":"SolverTools.jl","text":"","category":"section"},{"location":"SolverTools.html","page":"SolverTools","title":"SolverTools","text":"Documentation for SolverTools.jl","category":"page"},{"location":"SolverTools.html","page":"SolverTools","title":"SolverTools","text":"Modules = [IPGBs.SolverTools]","category":"page"},{"location":"SolverTools.html#IPGBs.SolverTools","page":"SolverTools","title":"IPGBs.SolverTools","text":"Includes various LP and IP functions using external solvers and JuMP.\n\n\n\n\n\n","category":"module"},{"location":"SolverTools.html#IPGBs.SolverTools.bounded_objective-Tuple{Matrix{Int64}, Int64, Vector{Int64}}","page":"SolverTools","title":"IPGBs.SolverTools.bounded_objective","text":"bounded_objective(A :: Matrix{Int}, i :: Int, sigma :: Vector{Int})\n\nCompute the objective function for the bounded case of the project-and-lift algorithm.\n\nBy Farkas Lemma, either A^σ x^σ + Aσ xσ = 0 has a solution with b^T x < 0 or y^T A^σ <= (b^σ)^T y^T Aσ == bσ^T has a solution. In this case of P&L, the latter holds and if y is a solution it follows that c = b - A^T y satisfies: cσ = 0 and c^T u = -ui for all u in ker(A).\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.cone_element-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Real","page":"SolverTools","title":"IPGBs.SolverTools.cone_element","text":"cone_element(\nrays :: Vector{Vector{T}}\n\n) :: Vector{Float64} where {T <: Real}\n\nReturn a point in the cone spanned by the rays in rays if it exists.\n\nThe point is computed via linear programming.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.feasibility_model-Tuple{Matrix{Int64}, Vector{Int64}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}, DataType}","page":"SolverTools","title":"IPGBs.SolverTools.feasibility_model","text":"feasibility_model(A :: Matrix{Int}, b :: Vector{Int}, u :: Vector{<: Union{Int, Nothing}}, nonnegative :: Vector{Bool}, var_type :: DataType)\n\nReturn a feasibility checking model along with variable and constraint vectors for Ax = b, 0 <= x <= u, where x is either an integer variable vector, if var_type == Int or a real variable vector otherwise.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_bounded-Tuple{JuMP.Model}","page":"SolverTools","title":"IPGBs.SolverTools.is_bounded","text":"is_bounded(model :: JuMP.Model)\n\nReturn true iff the IP/LP given by model is bounded.\n\nmodel is assumed to be feasible.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_degenerate-Tuple{JuMP.Model, Vector{JuMP.VariableRef}, Vector{JuMP.ConstraintRef}}","page":"SolverTools","title":"IPGBs.SolverTools.is_degenerate","text":"is_degenerate(model :: JuMP.Model, vars :: Vector{VariableRef}, constraints :: Vector{ConstraintRef})\n\nReturn true iff the optimal basis of model is degenerate, i.e. if any of its basic variables has value 0.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.is_feasible-Tuple{JuMP.Model}","page":"SolverTools","title":"IPGBs.SolverTools.is_feasible","text":"is_feasible(model :: JuMP.Model)\n\nReturn true iff the IP/LP given by model is feasible.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.jump_model-Tuple{Matrix{Int64}, Vector{Int64}, Array{Float64}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}, DataType}","page":"SolverTools","title":"IPGBs.SolverTools.jump_model","text":"jump_model(A :: Matrix{Int}, b :: Vector{Int}, C :: Array{Float64}, u :: Vector{Union{Int, Nothing}}, nonnegative :: Vector{Bool}, var_type :: DataType)\n\nReturn a JuMP model (alongside references to its variables and constraints) for the given IP or LP problem.\n\nThe optimization problem considered is min c[1, :] * x s.t. Ax = b, x_i >= 0 for all i s.t. nonnegative[i] == true\n\nThe variables are integer if var_type == Int or real otherwise.\n\nTODO: Should I do anything special for the binary case?\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.optimal_basis!-Tuple{JuMP.Model, Vector{JuMP.VariableRef}}","page":"SolverTools","title":"IPGBs.SolverTools.optimal_basis!","text":"optimal_basis!(model :: JuMP.Model) :: Vector{Bool}\n\nReturn a boolean vector with value true at index i iff the i-th variable is basic at the optimal solution of model.\n\nThis function calls optimize! on model in order to be self-contained.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.optimal_row_span-Union{Tuple{T}, Tuple{Matrix{Int64}, Vector{Int64}, Array{T}}, Tuple{Matrix{Int64}, Vector{Int64}, Array{T}, Symbol}} where T<:Real","page":"SolverTools","title":"IPGBs.SolverTools.optimal_row_span","text":"optimal_row_span(\nA::Matrix{Int},\nb::Vector{Int},\nC::Array{T},\nsense::Symbol = :Min\n\n)::Union{Vector{Float64},Nothing} where {T<:Real}\n\nCompute a vector in the row span of A given by yA where y is the optimal solution to the dual of the LP given by A, b, c.\n\nAssumes Ax = b is feasible, and max x s.t. Ax = b, x >= 0 is bounded. Given these conditions, the dual variables of the constraints of the above LP give a positive row span vector.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.optimal_weight_vector-Tuple{Matrix{Int64}, Vector{Int64}, Vector{Bool}}","page":"SolverTools","title":"IPGBs.SolverTools.optimal_weight_vector","text":"optimal_weight_vector(\nA :: Matrix{Int},\nb :: Vector{Int},\nunbounded :: Vector{Bool}\n\n) :: Tuple{Vector{Float64}, Float64}\n\nFind an extreme ray of the dual cone of Ax = 0 whenever possible.\n\nSee Malkin's thesis, page 83 for a description of the use of this\nidea in Gröbner basis truncation.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.positive_row_span-Tuple{Matrix{Int64}, Vector{Int64}}","page":"SolverTools","title":"IPGBs.SolverTools.positive_row_span","text":"positive_row_span(A :: Matrix{Int}, b :: Vector{Int})\n\nCompute a strictly positive vector in the row span of A using linear programming.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.relaxation_model-Tuple{Matrix{Int64}, Vector{Int64}, Array{Float64}, Vector{<:Union{Nothing, Int64}}, Vector{Bool}}","page":"SolverTools","title":"IPGBs.SolverTools.relaxation_model","text":"relaxation_model(A :: Matrix{Int}, b :: Vector{Int}, C :: Array{Float64}, u :: Vector{Union{Int, Nothing}}, nonnegative :: Vector{Bool})\n\nReturn a linear relaxation model of the given IP.\n\nThe optimization problem considered is of the form min C[1, :]' * x s.t. Ax = b, x >= 0.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.set_jump_objective!-Union{Tuple{T}, Tuple{JuMP.Model, Symbol, Vector{T}, Vector{JuMP.VariableRef}}} where T<:Real","page":"SolverTools","title":"IPGBs.SolverTools.set_jump_objective!","text":"set_jump_objective!(model :: JuMP.Model, direction :: Symbol, c :: Vector{T}, x :: Vector{JuMP.VariableRef}) where {T <: Real}\n\nUpdates model changing its objective function to c and sense to direction, which can be either :Max or :Min.\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.unboundedness_ip_model-Tuple{Matrix{Int64}, Vector{Bool}, Int64}","page":"SolverTools","title":"IPGBs.SolverTools.unboundedness_ip_model","text":"unboundedness_ip_model(A :: Matrix{Int}, nonnegative :: Vector{Bool}, i :: Int)\n\nReturn an IP that checks for the existence of an integer vector u such that Au = 0, u[nonnegative] >= 0, u[i] > 0.\n\nTODO: this could also be done with LP as follows: \"Assume all data is rational. Then, the polyhedron is rational, so the optimum must be rational. Multiply by a large enough integer...\" Implement it this way later!\n\n\n\n\n\n","category":"method"},{"location":"SolverTools.html#IPGBs.SolverTools.update_feasibility_model_rhs-Union{Tuple{T}, Tuple{Vector{JuMP.ConstraintRef}, Matrix{Int64}, Vector{Int64}, T}} where T<:AbstractVector{Int64}","page":"SolverTools","title":"IPGBs.SolverTools.update_feasibility_model_rhs","text":"update_feasibility_model_rhs(constraints :: Vector{ConstraintRef}, A :: Matrix{Int}, b :: Vector{Int}, v :: T) where {T <: AbstractVector{Int}}\n\nChange the RHS of constraints to b - A * v.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#MultiObjectiveAlgorithms.jl","page":"MultiObjectiveAlgorithms","title":"MultiObjectiveAlgorithms.jl","text":"","category":"section"},{"location":"MultiObjectiveAlgorithms.html","page":"MultiObjectiveAlgorithms","title":"MultiObjectiveAlgorithms","text":"Documentation for MultiObjectiveAlgorithms.jl","category":"page"},{"location":"MultiObjectiveAlgorithms.html","page":"MultiObjectiveAlgorithms","title":"MultiObjectiveAlgorithms","text":"Modules = [IPGBs.MultiObjectiveAlgorithms]","category":"page"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms","text":"A module to solve multi-objective integer programming problems using epsilon-constraint methods and test sets / Gröbner Bases.\n\n\n\n\n\n","category":"module"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.gbelems_with_positive_slack-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.gbelems_with_positive_slack","text":"gbelems_with_positive_slack(\ngb::Vector{Vector{Int}},\nslack_indices::Vector{Int}\n\n)::Vector{Vector{Int}}\n\nReturn the vectors in gb with no negative value and at least one strictly positive value in the slack_indices variables.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.minimal_steps-Tuple{Vector{Vector{Int64}}, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.minimal_steps","text":"minimalsteps(\ngb::Vector{Vector{Int}},\nx::Vector{Int}\n\n)::Vector{Vector{Int}}\n\nReturn the set of minimal steps in objective value from x that may yield new points of the Pareto frontier in an epsilon-constraint method.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.moip_gb-Tuple{IPGBs.MultiObjectiveAlgorithms.MOIPGBState}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.moip_gb","text":"moip_gb(s :: MOIPGBState) :: BinomialSet{Vector{Int}, MonomialOrder}\n\nGröbner Basis / test set for the multi-objective problem corresponding to the state s.\n\nThe GB can be computed using either 4ti2 or IPGBs, depending on the solver specified in s.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.moip_gb_solve-Tuple{IPGBs.IPInstances.IPInstance, Vector{Int64}}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.moip_gb_solve","text":"moip_gb_solve(\ninstance::IPInstance,\ninitial_solution::Vector{Int};\nsolver::String=\"4ti2\"\n\n)::Tuple{Vector{Vector{Int}}, Set{Vector{Int}}, Stats}\n\nPareto front for multi-objective instance given initial_solution, using solver.\n\nIf solver is a test-set based solver, applies the project-and-lift algorithm to obtain a solution.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.new_step_list-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.new_step_list","text":"new_step_list(steps :: Vector{Vector{Int}}, slacks :: Vector{Int}) :: Vector{Vector{Int}}\n\nAdd the slacks vector to the steps list if it is not dominated by any vector in steps, and remove from steps any vector dominated by slacks.\n\nIn the biobjective case this is unnecessary, but dropping useless steps can lead to better performance when there are 3+ objectives.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.push_efficient_point!-Tuple{IPGBs.MultiObjectiveAlgorithms.MOIPGBState, Vector{Int64}}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.push_efficient_point!","text":"push_efficient_point!(state :: MOIPGBState, point :: Vector{Int})\n\nUpdate state's efficient and nondominated sets with point whenever point is a previously unknown efficient solution.\n\n\n\n\n\n","category":"method"},{"location":"MultiObjectiveAlgorithms.html#IPGBs.MultiObjectiveAlgorithms.solve_current_moip!-Tuple{IPGBs.MultiObjectiveAlgorithms.MOIPGBState}","page":"MultiObjectiveAlgorithms","title":"IPGBs.MultiObjectiveAlgorithms.solve_current_moip!","text":"solve_current_moip!(s::MOIPGBState)\n\nSolve the scalarization of a MOIP given by s. If s.solver uses test sets, then a test set is computed, in case one is not already available. Otherwise, s.solver is used directly to solve the scalarization.\n\n\n\n\n\n","category":"method"},{"location":"GBTools.html#GBTools.jl","page":"GBTools","title":"GBTools.jl","text":"","category":"section"},{"location":"GBTools.html","page":"GBTools","title":"GBTools","text":"Documentation for GBTools.jl","category":"page"},{"location":"GBTools.html","page":"GBTools","title":"GBTools","text":"Modules = [IPGBs.GBTools]","category":"page"},{"location":"GBTools.html#IPGBs.GBTools.grevlex_matrix-Tuple{Int64}","page":"GBTools","title":"IPGBs.GBTools.grevlex_matrix","text":"Returns a matrix representing the grevlex order for n variables with xn > x{n-1} > ... > x_1\n\n\n\n\n\n","category":"method"},{"location":"GBTools.html#IPGBs.GBTools.lex_matrix-Tuple{Int64}","page":"GBTools","title":"IPGBs.GBTools.lex_matrix","text":"Returns a matrix representing the lex order for n variables with x1 > x2 > ... > x_n.\n\n\n\n\n\n","category":"method"},{"location":"GBTools.html#IPGBs.GBTools.revlex_matrix-Tuple{Int64}","page":"GBTools","title":"IPGBs.GBTools.revlex_matrix","text":"Returns a matrix representing the lex order for n variables with x1 < x2 < ... < x_n.\n\nThis is the tiebreaking order used by 4ti2.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#SignatureAlgorithms.jl","page":"SignatureAlgorithms","title":"SignatureAlgorithms.jl","text":"","category":"section"},{"location":"SignatureAlgorithms.html","page":"SignatureAlgorithms","title":"SignatureAlgorithms","text":"Documentation for SignatureAlgorithms.jl","category":"page"},{"location":"SignatureAlgorithms.html","page":"SignatureAlgorithms","title":"SignatureAlgorithms","text":"Modules = [IPGBs.SignatureAlgorithms]","category":"page"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms","text":"An implementation of a Signature-based algorithm for Gröbner bases of toric ideals.\n\n\n\n\n\n","category":"module"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.SignatureSet","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.SignatureSet","text":"Stores one SupportTree for each signature index. This enables fast divisor queries for Signatures.\n\n\n\n\n\n","category":"type"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.initialize!-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, Matrix{Int64}, Vector{Int64}, Matrix{Float64}, Vector{Int64}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.initialize!","text":"Initializes all data in algorithm. Must be called before using any of the data inside for GB computations.\n\nTODO almost all of this logic is still duplicated in Buchberger.jl. Can I do #this better?\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.late_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.late_pair_elimination","text":"Attempts to eliminate pair before building it as an explicit GBElement, after retrieving it from the priority queue for processing.\n\nReturns true iff pair may be eliminated at this point.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.next_pair!-Union{Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.next_pair!","text":"Generates the next pair to be processed by algorithm by picking the first element of its priority queue. Returns nothing if there are no more S-pairs to be processed and the algorithm may thus terminate.\n\nPairs are processed in order of increasing signature.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.process_zero_reduction!-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SigPoly{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.process_zero_reduction!","text":"Adds syzygy_element to the set of known syzygies of algorithm.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.GBAlgorithms.update!-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SigPoly{T}}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SigPoly{T}, Union{Nothing, IPGBs.SignaturePolynomials.SignaturePair}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.GBAlgorithms.update!","text":"Adds the element g to the current basis maintained by algorithm. Uses pair, if available, to generate new Koszul syzygies. pair is assumed to be the SignaturePair that was used to generate g.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.base_divisors_criterion-Union{Tuple{T}, Tuple{Int64, Int64, Int64, Union{Nothing, IPGBs.SignatureAlgorithms.LowBaseDiv}, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.base_divisors_criterion","text":"Applies the Base Divisors Criterion presented in Roune and Stillman (2012).\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.divided_by-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignatureAlgorithms.SignatureSet}","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.divided_by","text":"Returns true iff there is a signature in signatures that divides s. Uses SupportTrees for efficient divisor search.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.early_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, IPGBs.SignaturePolynomials.SignaturePair}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.early_pair_elimination","text":"Attempts to eliminate pair before putting it into the priority queue, but after computing its signature.\n\nReturns true iff pair may be eliminated at this point.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.enumerate_divisors-Tuple{IPGBs.SignaturePolynomials.Signature, IPGBs.SignatureAlgorithms.SignatureSet}","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.enumerate_divisors","text":"Returns a list of all divisors of s in signatures that are distinct from s.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.high_base_divisor-Union{Tuple{T}, Tuple{Int64, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.high_base_divisor","text":"Computes the index of the best high-ratio base divisor for the element of index j.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.high_base_divisors_criterion-Union{Tuple{T}, Tuple{Int64, Int64, Int64, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.high_base_divisors_criterion","text":"The Base divisor criterion for high-ratio elements. An element a is high-ratio if lt(a) | lt(b), where b is the new element being added.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.koszul_criterion-Union{Tuple{T}, Tuple{IPGBs.SignaturePolynomials.SignaturePair, DataStructures.BinaryHeap{IPGBs.SignaturePolynomials.Signature, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}, IPGBs.SignaturePolynomials.ModuleMonomialOrdering{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.koszul_criterion","text":"Applies the Koszul criterion to spair, returning true iff it can be eliminated by this criterion. The main idea is checking whether there exists a regular Koszul syzygy with the same signature as spair. If this happens, spair may be eliminated.\n\nTODO this isn't eliminating pretty much anything at all! Investigate\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.low_base_divisors_criterion-Union{Tuple{T}, Tuple{Int64, Int64, Union{Nothing, IPGBs.SignatureAlgorithms.LowBaseDiv}, IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.low_base_divisors_criterion","text":"The Base divisor criterion for low-ratio elements. An element a is low-ratio if signature(a) | signature(b), where b is the new element being added.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.signature_criterion-Tuple{IPGBs.SignaturePolynomials.SignaturePair, IPGBs.SignatureAlgorithms.SignatureSet}","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.signature_criterion","text":"Returns true iff spair is eliminated by the signature criterion, i.e. there is a known syzygy that divides its signature.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.update_queue!-Union{Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.update_queue!","text":"Adds new SignaturePairs to algorithm.heap. Applies early elimination of S-pairs when possible.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.update_syzygies!-Union{Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}}, Tuple{T}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.update_syzygies!","text":"Adds the Koszul syzygies corresponding to the newest element of gb to the syzygy list.\n\nCurrently unused, as this is inefficient. It's not necessary to add all Koszul syzygies.\n\n\n\n\n\n","category":"method"},{"location":"SignatureAlgorithms.html#IPGBs.SignatureAlgorithms.very_early_pair_elimination-Union{Tuple{T}, Tuple{IPGBs.SignatureAlgorithms.SignatureAlgorithm{T}, Int64, Union{Nothing, IPGBs.SignatureAlgorithms.LowBaseDiv}, Int64, Int64}} where T<:IPGBs.GBElements.GBElement","page":"SignatureAlgorithms","title":"IPGBs.SignatureAlgorithms.very_early_pair_elimination","text":"Attempts to eliminate the pair (i, j) before even creating it as a SignaturePair (thus, without computing its signature).\n\nReturns true iff (i, j) may be eliminated at this point.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#SupportTrees.jl","page":"SupportTrees","title":"SupportTrees.jl","text":"","category":"section"},{"location":"SupportTrees.html","page":"SupportTrees","title":"SupportTrees","text":"Documentation for SupportTrees.jl","category":"page"},{"location":"SupportTrees.html","page":"SupportTrees","title":"SupportTrees","text":"Modules = [IPGBs.SupportTrees]","category":"page"},{"location":"SupportTrees.html#IPGBs.SupportTrees","page":"SupportTrees","title":"IPGBs.SupportTrees","text":"Reimplementation of 4ti2's FilterReduction tree structure used to store binomial sets for efficient reductions. Called SupportTrees in reference to Roune and Stillman (2012).\n\n\n\n\n\n","category":"module"},{"location":"SupportTrees.html#IPGBs.SupportTrees.SupportNode","page":"SupportTrees","title":"IPGBs.SupportTrees.SupportNode","text":"Each binomial in the GB is inserted in some node of the tree.\n\nA filter is a list of indices of the binomials such that their coordinates are positive - that is, the list of indices of variables appearing in its leading term.\n\nA binomial is inserted in a node of the tree with the same filter as itself. All binomials with the same filter are inserted in the same node. If the tree corresponds to a GB (or a partial GB in some way) each node should contain at most one binomial in its binomial_list.\n\nEach child node is labeled by its (next) filter index.\n\n\n\n\n\n","category":"type"},{"location":"SupportTrees.html#IPGBs.SupportTrees.SupportTree","page":"SupportTrees","title":"IPGBs.SupportTrees.SupportTree","text":"The structure from 4ti2's FilterReduction for efficient reduction of binomials in toric ideals.\n\nAt each level i of the tree, there exists a node labeled j if there is some binomial in the tree whose filter's i-th element is j. Each binomial is stored at level n, with n the size of its filter.\n\nIf fullfilter is true, then both positive and negative entries of the binomials are considered to be in the filter for reduction. This is useful to implement the specialized truncated GB algorithm described in Thomas and Weismantel, Section 3.\n\n\n\n\n\n","category":"type"},{"location":"SupportTrees.html#IPGBs.SupportTrees.SupportTree-Union{Tuple{S}, Tuple{T}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.SupportTree","text":"Puts references to the elements of gb in a reduction tree, so that one may easily find whether a given binomial can be reduced by gb.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.add_binomial!-Union{Tuple{T}, Tuple{IPGBs.SupportTrees.SupportTree{T}, T}} where T<:AbstractVector{Int64}","page":"SupportTrees","title":"IPGBs.SupportTrees.add_binomial!","text":"Adds a (reference to a) binomial to a SupportTree.\n\nThe idea is adding the binomial to a node corresponding precisely to its filter. At each iteration, take the i-th element of the filter of binomial. If there is already a node in the tree at level i labeled by the i-th index in the filter of binomial, move to the subtree defined by that node. Otherwise, create such a node.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.enumerate_reducers!-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{Vector{T}, P, S, IPGBs.SupportTrees.SupportNode{T}}} where {P<:AbstractVector{Int64}, T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.enumerate_reducers!","text":"Walks in the tree recursively pushing any reducers found to reducers.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.enumerate_reducers-Union{Tuple{S}, Tuple{T}, Tuple{P}, Tuple{P, S, IPGBs.SupportTrees.SupportTree{T}}} where {P<:AbstractVector{Int64}, T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.enumerate_reducers","text":"Returns a vector containing all reducers of g in gb, using tree to find them efficiently.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.find_reducer-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.SupportNode{T}, IPGBs.SupportTrees.TreeStats}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.find_reducer","text":"Checks whether g is reducible by some element of gb and, if so, returns a reducer. Otherwise, returns nothing.\n\nThis is done by looking up a node in this subtree with a subfilter of g's filter and then checking directly whether some binomial in the node reduces g.\n\nThe lookup operation traverses the tree looking for nodes whose labels are contained in the filter of g.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.find_reducer-Union{Tuple{S}, Tuple{T}, Tuple{T, S, IPGBs.SupportTrees.SupportTree{T}}} where {T<:AbstractVector{Int64}, S<:AbstractVector{T}}","page":"SupportTrees","title":"IPGBs.SupportTrees.find_reducer","text":"Checks whether g is reducible by some element of gb and, if so, returns a reducer. Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"SupportTrees.html#IPGBs.SupportTrees.remove_binomial!-Union{Tuple{T}, Tuple{IPGBs.SupportTrees.SupportTree{T}, T}} where T<:AbstractVector{Int64}","page":"SupportTrees","title":"IPGBs.SupportTrees.remove_binomial!","text":"Removes binomial from tree by doing a lookup operation and then just removes it from the corresponding binomial_list.\n\nIf binomial is not in tree, nothing will happen.\n\n\n\n\n\n","category":"method"},{"location":"MatrixTools.html#MatrixTools.jl","page":"MatrixTools","title":"MatrixTools.jl","text":"","category":"section"},{"location":"MatrixTools.html","page":"MatrixTools","title":"MatrixTools","text":"Documentation for MatrixTools.jl","category":"page"},{"location":"MatrixTools.html","page":"MatrixTools","title":"MatrixTools","text":"Modules = [IPGBs.MatrixTools]","category":"page"},{"location":"MatrixTools.html#IPGBs.MatrixTools.hnf_lattice_basis-Tuple{Matrix{Int64}}","page":"MatrixTools","title":"IPGBs.MatrixTools.hnf_lattice_basis","text":"hnf_lattice_basis(A :: Matrix{Int})\n\nReturn a row basis for the lattice ker(A) computed using the Upper\nHermite Normal Form. The entries of this basis tend to be smaller than\nthose computed directly from kernel(A).\n\n\n\n\n\n","category":"method"},{"location":"MatrixTools.html#IPGBs.MatrixTools.initial_solution-Tuple{Matrix{Int64}, Vector{Int64}}","page":"MatrixTools","title":"IPGBs.MatrixTools.initial_solution","text":"initial_solution(\nA :: Matrix{Int},\nb :: Vector{Int}\n\n) :: Vector{Int}\n\nReturn a solution to instance.A * x == instance.b, dropping the non-negativity constraints.\n\n\n\n\n\n","category":"method"},{"location":"MatrixTools.html#IPGBs.MatrixTools.is_normalized_hnf-Union{Tuple{AbstractAlgebra.Generic.MatSpaceElem{T}}, Tuple{T}} where T","page":"MatrixTools","title":"IPGBs.MatrixTools.is_normalized_hnf","text":"is_normalized_hnf(H :: Generic.MatSpaceElem{T})\n\nReturn true iff H is in normalized HNF form as defined in normalize_hnf!.\n\n\n\n\n\n","category":"method"},{"location":"MatrixTools.html#IPGBs.MatrixTools.lift_vector-Tuple{Vector{Int64}, AbstractAlgebra.Generic.MatSpaceElem{Int64}, AbstractAlgebra.Generic.MatSpaceElem{Int64}}","page":"MatrixTools","title":"IPGBs.MatrixTools.lift_vector","text":"lift_vector(\nv :: Vector{Int},\nprojected_basis :: Generic.MatSpaceElem{Int},\nlattice_basis :: Generic.MatSpaceElem{Int}\n\n) :: Vector{Int}\n\nLift v from an (extended) group relaxation to the full problem given by instance.\n\n\n\n\n\n","category":"method"},{"location":"MatrixTools.html#IPGBs.MatrixTools.normalize_hnf!-Union{Tuple{AbstractAlgebra.Generic.MatSpaceElem{T}}, Tuple{T}} where T","page":"MatrixTools","title":"IPGBs.MatrixTools.normalize_hnf!","text":"normalize_hnf!(H :: Generic.MatSpaceElem{T})\n\nChange H to an upper row HNF matrix satisfying the following property: all entries above a pivot are non-positive and of smaller magnitude than the pivot\n\nAssumes H is already in HNF as defined by AbstractAlgebra.jl, that is, it is in upper row HNF satisfying:\n\nall entries above a pivot are non-negative and of smaller magnitude than the pivot\n\n\n\n\n\n","category":"method"},{"location":"MatrixTools.html#IPGBs.MatrixTools.solve-Tuple{Matrix{Int64}, Vector{Int64}}","page":"MatrixTools","title":"IPGBs.MatrixTools.solve","text":"solve(A :: Matrix{Int}, b :: Vector{Int}) :: Vector{Int}\n\nA solution to Ax = b, that is, an element of the fiber of right-hand side\n`b` in the lattice ker(A).\n\n\n\n\n\n","category":"method"},{"location":"MonomialHeaps.html#MonomialHeaps.jl","page":"MonomialHeaps","title":"MonomialHeaps.jl","text":"","category":"section"},{"location":"MonomialHeaps.html","page":"MonomialHeaps","title":"MonomialHeaps","text":"Documentation for MonomialHeaps.jl","category":"page"},{"location":"MonomialHeaps.html","page":"MonomialHeaps","title":"MonomialHeaps","text":"Modules = [IPGBs.MonomialHeaps]","category":"page"},{"location":"MonomialHeaps.html#IPGBs.MonomialHeaps.MonomialHeap","page":"MonomialHeaps","title":"IPGBs.MonomialHeaps.MonomialHeap","text":"Keeps a priority list / heap of monomials, ordered by weight, without repetitions. The number of times any monomial is inserted is stored in the WeightedMonomial structure.\n\n\n\n\n\n","category":"type"},{"location":"MonomialHeaps.html#IPGBs.MonomialHeaps.WeightedMonomial","page":"MonomialHeaps","title":"IPGBs.MonomialHeaps.WeightedMonomial","text":"Monomial with weight given by a monomial order, used for fast comparison in a priority queue or heap. It also includes a count to keep track of how many times this monomial has been generated. FGLM can use this to check whether some monomial is underneath a GB staircase efficiently.\n\n\n\n\n\n","category":"type"},{"location":"IPGBs.html#IPGBs.jl","page":"IPGBs","title":"IPGBs.jl","text":"","category":"section"},{"location":"IPGBs.html","page":"IPGBs","title":"IPGBs","text":"Documentation for IPGBs.jl","category":"page"},{"location":"IPGBs.html","page":"IPGBs","title":"IPGBs","text":"Modules = [IPGBs]","category":"page"},{"location":"IPGBs.html#IPGBs.groebner_basis","page":"IPGBs","title":"IPGBs.groebner_basis","text":"groebner_basis(\ninstance :: IPInstance,\nmarkov_basis :: Union{Vector{Vector{Int}}, Nothing} = nothing;\nkwargs...\n\n) :: Vector{Vector{Int}}\n\nReturn a Gröbner basis of `instance` using the given `markov_basis` if\nit is available. Otherwise, a Markov basis is computed first.\n\nKeyword parameters:\n- quiet: Whether to print information about the computation\n- use_signatures: Whether to use signatures in the computation (work in progress)\n- implicit_representation: Whether to represent slack variables implicitly or not (as described in Thomas and Weismantel (1997))\n- truncation_type: The type of truncation to use. Can be :Heuristic, :LP, :IP, :Simple, or :None\n- use_quick_truncation: Whether to use grading-based truncation\n- use_binary_truncation: Whether to use the binary truncation criterion for binary variables\n- solutions: A vector with known feasible solutions to be optimized\n- module_order: The module order to use in a signature GB computation (work in progress)\n\n\n\n\n\n","category":"function"},{"location":"IPGBs.html#IPGBs.use_simple_truncation-Tuple{Matrix{Int64}, Vector{Int64}}","page":"IPGBs","title":"IPGBs.use_simple_truncation","text":"Simple truncation works when the data in A, b are all non-negative. This is more efficient than IP truncation, and is exact, contrary to LP truncation, so it should be used whenever possible.\n\nThis function returns whether simple truncation can be used.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Documentation-for-the-IPGBs-project","page":"Documentation for the IPGBs project","title":"Documentation for the IPGBs project","text":"","category":"section"},{"location":"index.html","page":"Documentation for the IPGBs project","title":"Documentation for the IPGBs project","text":"","category":"page"},{"location":"index.html#Index","page":"Documentation for the IPGBs project","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Documentation for the IPGBs project","title":"Documentation for the IPGBs project","text":"","category":"page"}]
}
