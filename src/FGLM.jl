module FGLM

using IPGBs.BinomialSets
using IPGBs.GBElements
using IPGBs.Orders
using IPGBs.MonomialHeaps

"""
    update_monomial_heap!(h :: MonomialHeap{T}, m :: Vector{Int}) where {T <: GBOrder}

Add all monomials of the form x_i * `m` for all variables x_i to the heap `h` and count repetitions.
"""
function update_monomial_heap!(
    h :: MonomialHeap{T},
    m :: Vector{Int}
) where {T <: GBOrder}
    n = length(m)
    for i in 1:n
        new_monom = copy(m)
        new_monom[i] += 1
        push!(h, m) #Push will deal with the repetitions, if needed
    end
end

"""
Auxiliary struct for FGLM. Represents a monomial in the standard basis of the
target order in the algorithm. For efficiency, these monomials are stored
alongside their normal forms, which are known.
"""
struct StdBasisMonomial
    monomial :: Vector{Int}
    normal_form :: Vector{Int}
end

"""
    find_linear_dependency(nf :: Vector{Int}, std_basis :: Vector{StdBasisMonomial})

Return 0 if there's no element in `std_basis` with normal form `nf`.
Otherwise, returns the index of an element with this normal form.

TODO this is terribly inefficient. This search can be done using a tree or
in some other way.
"""
function find_linear_dependency(
    nf :: Vector{Int},
    std_basis :: Vector{StdBasisMonomial}
) :: Int
    for i in 1:length(std_basis)
        if std_basis[i].normal_form == nf
            return i
        end
    end
    return 0
end

"""
    is_below_staircase(m :: Vector{Int}, gb :: Vector{T}) where {T}

Checks whether `m` is below the staircase given by `gb`.
Naïve implementation. It is possible to do this more efficiently by counting
the number of times FGLM generated `m`.
"""
function is_below_staircase(
    m :: WeightedMonomial,
    gb :: Vector{T}
) :: Bool where {T}
    for basis_monom in gb
        if all(basis_monom[i] <= m[i] for i in 1:length(m))
            return false
        end
    end
    return true
end

"""
    is_below_staircase_fast(m :: WeightedMonomial)

Check whether `m` is below a GB staircase indirectly by counting how many times
it was inserted in the priority queue.

This idea comes straight from the original FGLM paper Faugère et al (1994).
"""
function is_below_staircase_fast(
    m :: WeightedMonomial
) :: Bool
    return m.count < length(m.monomial)
end

"""
    fglm(gb1 :: BinomialSet{T, S}, target_order :: S) where {T, S <: GBOrder}

Convert a Gröbner basis `gb1` to `target_order` using the FGLM algorithm.

FGLM only works when the ideal generated by `gb1` is zero-dimensional. This
is assumed in the implementation.
"""
function fglm(
    gb1 :: BinomialSet{T, S},
    target_order :: S
) :: BinomialSet{T, S} where {T, S <: GBOrder}
    if isempty(gb1)
        return BinomialSet(T[], target_order)
    end
    n = length(gb1[1])
    one = zeros(Int, n) #The monomial 1
    next_monomials = MonomialHeap(target_order, [ one ])
    std_basis = StdBasisMonomial[]
    gb2 = T[]
    while !isempty(next_monomials)
        m = pop!(next_monomials)
        if is_below_staircase_fast(m)
            #TODO also note that m is a WeightedMonomial here
            normal_form = BinomialSets.reduce!(m, gb1) #TODO the typing in reduce probably doesn't allow this, I'll have to fix it later
            ld = find_linear_dependency(normal_form, std_basis)
            if ld == 0 #Linearly independent case, new std_basis monomial
                push!(std_basis, StdBasisMonomial(m.monomial, normal_form))
                update_monomial_heap!(next_monomials, m.monomial)
            else #Linearly dependent case, new gb2 binomial
                new_binomial = m.monomial - std_basis[ld].monomial
                new_elem = to_gbelement(new_binomial, target_order, T)
                push!(gb2, new_elem)
            end
        end
    end
    return BinomialSet(gb2, target_order)
end

end
