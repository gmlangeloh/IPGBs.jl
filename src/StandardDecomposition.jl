module StandardDecomposition
export standard_decomposition

"""
Represents an admissible pair, i.e., (x^m, σ) where x^m is a standard
monomial and σ is a set of indices disjoint from the support of m.

Additionally, for this pair to be standard, it has to be minimal w.r.t.
the following order:
(x^m, σ) <= (x^m', σ') iff x^m divides x^m' and
supp(x^m' / x^m) ∪ σ' ⊆ σ.

The minimal elements w.r.t. this order are the standard pairs and they
cover other admissible pairs.
"""
struct AdmissiblePair
    monomial :: Vector{Int} #Some standard monomial
    sigma :: Vector{Bool} #A set of variable indices with disjoint support
    #with `monomial`
end

function AdmissiblePair(t :: Tuple{Vector{Int}, Vector{Bool}})
    return AdmissiblePair(t[1], t[2])
end

to_tuple(pair :: AdmissiblePair) = (pair.monomial, pair.sigma)

function Base.show(io :: IO, pair :: AdmissiblePair)
    print(io, "(", pair.monomial, ", ", pair.sigma, ")")
end

"""
Implements the following order:
(x^m, σ) <= (x^m', σ') iff x^m divides x^m' and
supp(x^m' / x^m) ∪ σ' ⊆ σ.
"""
function less_than(pair1 :: AdmissiblePair, pair2 :: AdmissiblePair)
    n = length(pair1.monomial)
    divides = all(i -> pair1.monomial[i] <= pair2.monomial[i], 1:n)
    if !divides
        return false
    end
    #Check whether the condition on supports is satisfied
    for i in 1:n
        in_supp = (pair2.monomial[i] - pair1.monomial[i]) > 0
        if (in_supp || pair2.sigma[i]) && !pair1.sigma[i]
            return false
        end
    end
    return true
end

function is_unit_ideal(monomial_ideal :: Vector{Vector{Int}})
    return any(gen -> iszero(gen), monomial_ideal)
end

"""
Chooses some generator of the monomial ideal `M`. For now, it simply picks the
first one.

TODO If I ever care about the performance of the standard decomposition, I can
try to study whether it matters which generator is picked or not.
"""
choose_generator(M :: Vector{Vector{Int}}) = M[1]

"""
Chooses some variable in the support of `monomial`. For now, it simply picks
the first one.

TODO The same comments from `choose_generator` apply here.
"""
function choose_variable(monomial :: Vector{Int})
    for i in 1:length(monomial)
        if monomial[i] != 0
            return i
        end
    end
    return -1 #This should never happen unless the monomial is 1
end

"""
Quotient of (M : (gen / x^i)).
The generators of the quotient are the generators m of M divided by gcd(m, gen / x^i)
"""
function ideal_quotient(M :: Vector{Vector{Int}}, gen :: Vector{Int}, i :: Int)
    n = length(gen)
    gens = Vector{Int}[]
    for m in M
        new_gen = copy(m)
        for j in 1:n
            if i == j
                new_gen[j] -= min(m[j], gen[j] - 1)
            else
                new_gen[j] -= min(m[j], gen[j])
            end
        end
        push!(gens, new_gen)
    end
    return gens
end

"""
Returns true iff the support of monomial is contained in the set represented
by sigma.
"""
function support_in(monomial :: Vector{Int}, sigma :: Vector{Bool})
    for i in 1:length(monomial)
        if monomial[i] != 0 && !sigma[i]
            return false
        end
    end
    return true
end

#TODO I have no clue why this works, I need to read the proof of correctness
#of the algorithm
function candidate_pair(
    w :: Vector{Int},
    sigma :: Vector{Bool}
) :: AdmissiblePair
    cand = copy(w)
    for i in eachindex(cand)
        if sigma[i]
            cand[i] = 0
        end
    end
    return AdmissiblePair(cand, sigma)
end

"""
`pair` is_standard when it is not dominated by any already known standard pairs.
"""
function is_standard(pair :: AdmissiblePair, std_pairs :: Vector{AdmissiblePair})
    for std_pair in std_pairs
        if less_than(std_pair, pair)
            return false
        end
    end
    return true
end

"""
Updates the set of minimal generators of the ideal generated by `gens` upon adding
`new_gen`.
"""
function update_ideal!(gens :: Vector{Vector{Int}}, new_gen :: Vector{Int})
    #Check whether new_gen is a multiple of some previous generator
    n = length(new_gen)
    for gen in gens
        if all(i -> gen[i] <= new_gen[i], 1:n)
            return
        end
    end
    filter!(gen -> !all(i -> new_gen[i] <= gen[i], 1:n), gens)
    push!(gens, new_gen)
end

"""
True iff some generator in `gens` reduces the i-th element of gens.
"""
function is_reducible(i :: Int, gens :: Vector{Vector{Int}})
    n = length(gens[1])
    for j in 1:length(gens)
        if i != j && all(k -> gens[j][k] <= gens[i][k], 1:n)
            return true
        end
    end
    return false
end

"""
Reduces a set of generators `gens` to a set of minimal generators of the same
monomial ideal.
"""
function minimal_generators(gens :: Vector{Vector{Int}})
    indices = filter(i -> !is_reducible(i, gens), 1:length(gens))
    return gens[indices]
end

"""
Implementation of the standard decomposition algorithm introduced in Hosten
and Thomas (1998).
"""
function standard_decomposition(
    monomial_ideal :: Vector{Vector{Int}}
) :: Vector{Tuple{Vector{Int}, Vector{Bool}}}
    @assert !isempty(monomial_ideal)
    standard_pairs = AdmissiblePair[] #List of standard pairs that will be computed
    n = length(monomial_ideal[1]) #Number of variables of the base ring
    M = minimal_generators(monomial_ideal)
    unitary = is_unit_ideal(M)
    while !unitary
        w = zeros(Int, n)
        sigma = ones(Bool, n)
        M2 = copy(M)
        while !isempty(M2)
            gen = choose_generator(M2)
            i = choose_variable(gen)
            #Compute w := w * (gen / x^i)
            for j in 1:n
                w[j] += gen[j]
                if i == j
                    w[j] -= 1
                end
            end
            sigma[i] = false
            M2 = ideal_quotient(M2, gen, i)
            M2 = minimal_generators(M2)
            filter!(gen -> support_in(gen, sigma), M2)
        end
        pair = candidate_pair(w, sigma)
        if is_standard(pair, standard_pairs)
            push!(standard_pairs, pair)
        end
        if iszero(w)
            unitary = true
        end
        update_ideal!(M, w)
    end
    return map(pair -> to_tuple(pair), standard_pairs)
end

end
